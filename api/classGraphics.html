<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>JUCE: Graphics Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">JUCE
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Graphics Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="Graphics" -->
<p>A graphics context, used for drawing a component or image.  
 <a href="classGraphics.html#details">More...</a></p>

<p><a href="classGraphics-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics_1_1ScopedSaveState.html">ScopedSaveState</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses RAII to save and restore the state of a graphics context.  <a href="classGraphics_1_1ScopedSaveState.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a5da218e649d1b5ac3d67443ae77caf87">ResamplingQuality</a> { <a class="el" href="classGraphics.html#a5da218e649d1b5ac3d67443ae77caf87a4eb9cfa2e544befd2d50708e3316b28e">lowResamplingQuality</a> =  0, 
<a class="el" href="classGraphics.html#a5da218e649d1b5ac3d67443ae77caf87a5d8dfbf84457e91eb309b1402562f2af">mediumResamplingQuality</a> =  1, 
<a class="el" href="classGraphics.html#a5da218e649d1b5ac3d67443ae77caf87ae3c4b3cdf28f0aefc035977522675e8e">highResamplingQuality</a> =  2
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of rendering quality that can be specified when drawing images.  <a href="classGraphics.html#a5da218e649d1b5ac3d67443ae77caf87">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ada6375a2e6bf68758a2191acb4d62c65">Graphics</a> (const <a class="el" href="classImage.html">Image</a> &amp;imageToDrawOnto)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classGraphics.html" title="A graphics context, used for drawing a component or image.">Graphics</a> object to draw directly onto the given image.  <a href="#ada6375a2e6bf68758a2191acb4d62c65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a7841c9a961ac9bca33bd30ddf8066cdb">~Graphics</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a7841c9a961ac9bca33bd30ddf8066cdb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#af17c43bb97e6822aa4b7b8a8adc40b99">setColour</a> (const <a class="el" href="classColour.html">Colour</a> &amp;newColour)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the current drawing colour.  <a href="#af17c43bb97e6822aa4b7b8a8adc40b99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a1ce91a31ec1258a73ace93b6c337dbb2">setOpacity</a> (float newOpacity)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the opacity to use with the current colour.  <a href="#a1ce91a31ec1258a73ace93b6c337dbb2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a57478bc2496ebb84696e5ba64b455965">setGradientFill</a> (const <a class="el" href="classColourGradient.html">ColourGradient</a> &amp;gradient)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the context to use a gradient for its fill pattern.  <a href="#a57478bc2496ebb84696e5ba64b455965"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a675cd4c4715165f0a0aec0bd8c3fe390">setTiledImageFill</a> (const <a class="el" href="classImage.html">Image</a> &amp;imageToUse, int anchorX, int anchorY, float opacity)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the context to use a tiled image pattern for filling.  <a href="#a675cd4c4715165f0a0aec0bd8c3fe390"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a763ea233d7b7c8e45e33c7ea8030ff48">setFillType</a> (const <a class="el" href="classFillType.html">FillType</a> &amp;newFill)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the current fill settings.  <a href="#a763ea233d7b7c8e45e33c7ea8030ff48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a1fbdb321975d90c45243027a61ac2be9">setFont</a> (const <a class="el" href="classFont.html">Font</a> &amp;newFont)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the font to use for subsequent text-drawing functions.  <a href="#a1fbdb321975d90c45243027a61ac2be9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#af6e07de35e7d2777f9152633b0932fbd">setFont</a> (float newFontHeight, int fontStyleFlags=<a class="el" href="classFont.html#a52a35b5dc1e6f782e25283c9283bae4fa99039e6bb438434f9bccde132132dd99">Font::plain</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the size and style of the currently-selected font.  <a href="#af6e07de35e7d2777f9152633b0932fbd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFont.html">Font</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#abb972f0d801630b6e02d335cfa9da28a">getCurrentFont</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the currently selected font.  <a href="#abb972f0d801630b6e02d335cfa9da28a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ade61955c11b56c91232b350dbfbf1b81">drawSingleLineText</a> (const <a class="el" href="classString.html">String</a> &amp;text, int startX, int baselineY, const <a class="el" href="classJustification.html">Justification</a> &amp;justification=<a class="el" href="classJustification.html#a4b9db354585c335c96baecf1a14c2db5a56156bb2892e32febf8011af9c5da653">Justification::left</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a one-line text string.  <a href="#ade61955c11b56c91232b350dbfbf1b81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a37c017a9d2f32bcd677f61f5de97ab9a">drawMultiLineText</a> (const <a class="el" href="classString.html">String</a> &amp;text, int startX, int baselineY, int maximumLineWidth) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws text across multiple lines.  <a href="#a37c017a9d2f32bcd677f61f5de97ab9a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a837821b4bab764d76df560350e069b45">drawTextAsPath</a> (const <a class="el" href="classString.html">String</a> &amp;text, const <a class="el" href="classAffineTransform.html">AffineTransform</a> &amp;transform) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a string of text as a vector path.  <a href="#a837821b4bab764d76df560350e069b45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#aa03c871748cf584b548663b79da7926c">drawText</a> (const <a class="el" href="classString.html">String</a> &amp;text, int x, int y, int width, int height, const <a class="el" href="classJustification.html">Justification</a> &amp;justificationType, bool useEllipsesIfTooBig) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a line of text within a specified rectangle.  <a href="#aa03c871748cf584b548663b79da7926c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ad2c56e11c42bc7404233b9a23e939ede">drawFittedText</a> (const <a class="el" href="classString.html">String</a> &amp;text, int x, int y, int width, int height, const <a class="el" href="classJustification.html">Justification</a> &amp;justificationFlags, int maximumNumberOfLines, float minimumHorizontalScale=0.7f) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to draw a text string inside a given space.  <a href="#ad2c56e11c42bc7404233b9a23e939ede"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a516a7795e6e0c6c70eb982a83ea0b8c3">fillAll</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the context's entire clip region with the current colour or brush.  <a href="#a516a7795e6e0c6c70eb982a83ea0b8c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a29e9bc174cf54be0f423172e24d5cf78">fillAll</a> (const <a class="el" href="classColour.html">Colour</a> &amp;colourToUse) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the context's entire clip region with a given colour.  <a href="#a29e9bc174cf54be0f423172e24d5cf78"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ac2202ef993b53d77d8646ed4ce3ea9d1">fillRect</a> (int x, int y, int width, int height) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a rectangle with the current colour or brush.  <a href="#ac2202ef993b53d77d8646ed4ce3ea9d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a9ff78524c757a302ad8b9cbc4c7ba851">fillRect</a> (const <a class="el" href="classRectangle.html">Rectangle</a>&lt; int &gt; &amp;rectangle) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a rectangle with the current colour or brush.  <a href="#a9ff78524c757a302ad8b9cbc4c7ba851"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a018bffc13a318cb5e59d29b258313b8b">fillRect</a> (float x, float y, float width, float height) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a rectangle with the current colour or brush.  <a href="#a018bffc13a318cb5e59d29b258313b8b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a1049a2dae8a1ae3e5e57238f2fd36a84">fillRoundedRectangle</a> (float x, float y, float width, float height, float cornerSize) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the current colour or brush to fill a rectangle with rounded corners.  <a href="#a1049a2dae8a1ae3e5e57238f2fd36a84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#afc06f32c228086e55876184176314bd1">fillRoundedRectangle</a> (const <a class="el" href="classRectangle.html">Rectangle</a>&lt; float &gt; &amp;rectangle, float cornerSize) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the current colour or brush to fill a rectangle with rounded corners.  <a href="#afc06f32c228086e55876184176314bd1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a359717e34bed0f5dfd2f3004b3cea19f">fillCheckerBoard</a> (const <a class="el" href="classRectangle.html">Rectangle</a>&lt; int &gt; &amp;area, int checkWidth, int checkHeight, const <a class="el" href="classColour.html">Colour</a> &amp;colour1, const <a class="el" href="classColour.html">Colour</a> &amp;colour2) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a rectangle with a checkerboard pattern, alternating between two colours.  <a href="#a359717e34bed0f5dfd2f3004b3cea19f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a28baf90f8e11ec6f96c349f45e09a9d0">drawRect</a> (int x, int y, int width, int height, int lineThickness=1) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws four lines to form a rectangular outline, using the current colour or brush.  <a href="#a28baf90f8e11ec6f96c349f45e09a9d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a7b8a15c73c5d797cd169852224236f4f">drawRect</a> (float x, float y, float width, float height, float lineThickness=1.0f) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws four lines to form a rectangular outline, using the current colour or brush.  <a href="#a7b8a15c73c5d797cd169852224236f4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a88e7c28b48c3f2e9e2c9df7d2571908f">drawRect</a> (const <a class="el" href="classRectangle.html">Rectangle</a>&lt; int &gt; &amp;rectangle, int lineThickness=1) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws four lines to form a rectangular outline, using the current colour or brush.  <a href="#a88e7c28b48c3f2e9e2c9df7d2571908f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a78541e36136eb040c4b8c81d4b8db8dd">drawRoundedRectangle</a> (float x, float y, float width, float height, float cornerSize, float lineThickness) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the current colour or brush to draw the outline of a rectangle with rounded corners.  <a href="#a78541e36136eb040c4b8c81d4b8db8dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a91706e86b7120523346fee8f2161d48f">drawRoundedRectangle</a> (const <a class="el" href="classRectangle.html">Rectangle</a>&lt; float &gt; &amp;rectangle, float cornerSize, float lineThickness) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the current colour or brush to draw the outline of a rectangle with rounded corners.  <a href="#a91706e86b7120523346fee8f2161d48f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a9785e9e0d63e8576db415decc7f5b2cd">drawBevel</a> (int x, int y, int width, int height, int bevelThickness, const <a class="el" href="classColour.html">Colour</a> &amp;topLeftColour=<a class="el" href="classColours.html#a9e57055bbdf8261e776d2ea8bb44514a">Colours::white</a>, const <a class="el" href="classColour.html">Colour</a> &amp;bottomRightColour=<a class="el" href="classColours.html#aad3910013bf00a80305c082284cd5ee2">Colours::black</a>, bool useGradient=true, bool sharpEdgeOnOutside=true) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a 3D raised (or indented) bevel using two colours.  <a href="#a9785e9e0d63e8576db415decc7f5b2cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a69e70db1afc03d58f9055f8f45d8e5d1">setPixel</a> (int x, int y) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a pixel using the current colour or brush.  <a href="#a69e70db1afc03d58f9055f8f45d8e5d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ab6fdfd1cb32b32d52b6b30df36321f70">fillEllipse</a> (float x, float y, float width, float height) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills an ellipse with the current colour or brush.  <a href="#ab6fdfd1cb32b32d52b6b30df36321f70"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ac88110d5407539aa1be841a89d5170b0">drawEllipse</a> (float x, float y, float width, float height, float lineThickness) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws an elliptical stroke using the current colour or brush.  <a href="#ac88110d5407539aa1be841a89d5170b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a0911bf63fd6c0d3e35b2b701fcbc7728">drawLine</a> (float startX, float startY, float endX, float endY) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a line between two points.  <a href="#a0911bf63fd6c0d3e35b2b701fcbc7728"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a664643f9fef3c8b37b0620c28ec4bb76">drawLine</a> (float startX, float startY, float endX, float endY, float lineThickness) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a line between two points with a given thickness.  <a href="#a664643f9fef3c8b37b0620c28ec4bb76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a94cf6a3a058ad1a36dc836b34916ef0d">drawLine</a> (const <a class="el" href="classLine.html">Line</a>&lt; float &gt; &amp;line) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a line between two points.  <a href="#a94cf6a3a058ad1a36dc836b34916ef0d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ace7c180c66f119399acb69ad966057e3">drawLine</a> (const <a class="el" href="classLine.html">Line</a>&lt; float &gt; &amp;line, float lineThickness) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a line between two points with a given thickness.  <a href="#ace7c180c66f119399acb69ad966057e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ab24a3f2ba3d648285fcad7c97fb8270f">drawDashedLine</a> (const <a class="el" href="classLine.html">Line</a>&lt; float &gt; &amp;line, const float *dashLengths, int numDashLengths, float lineThickness=1.0f, int dashIndexToStartFrom=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a dashed line using a custom set of dash-lengths.  <a href="#ab24a3f2ba3d648285fcad7c97fb8270f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a042d4f7223a63212ae1d9452e26cbd7a">drawVerticalLine</a> (int x, float top, float bottom) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a vertical line of pixels at a given x position.  <a href="#a042d4f7223a63212ae1d9452e26cbd7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#aeea9ba47ff90bb7643038692bf647738">drawHorizontalLine</a> (int y, float left, float right) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a horizontal line of pixels at a given y position.  <a href="#aeea9ba47ff90bb7643038692bf647738"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a129aa4c9dcc137a1c910a2f5ef118fb7">fillPath</a> (const <a class="el" href="classPath.html">Path</a> &amp;path, const <a class="el" href="classAffineTransform.html">AffineTransform</a> &amp;transform=<a class="el" href="classAffineTransform.html#a2173017e6300f667a23467505ca36276">AffineTransform::identity</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a path using the currently selected colour or brush.  <a href="#a129aa4c9dcc137a1c910a2f5ef118fb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a5bd626168d02b83d10123e398da5c5a7">strokePath</a> (const <a class="el" href="classPath.html">Path</a> &amp;path, const <a class="el" href="classPathStrokeType.html">PathStrokeType</a> &amp;strokeType, const <a class="el" href="classAffineTransform.html">AffineTransform</a> &amp;transform=<a class="el" href="classAffineTransform.html#a2173017e6300f667a23467505ca36276">AffineTransform::identity</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a path's outline using the currently selected colour or brush.  <a href="#a5bd626168d02b83d10123e398da5c5a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ab1484b102f99384c443cfb5881d68fa9">drawArrow</a> (const <a class="el" href="classLine.html">Line</a>&lt; float &gt; &amp;line, float lineThickness, float arrowheadWidth, float arrowheadLength) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a line with an arrowhead at its end.  <a href="#ab1484b102f99384c443cfb5881d68fa9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a0f8160f9b0a6866e40cf1a2b45c3b892">setImageResamplingQuality</a> (const <a class="el" href="classGraphics.html#a5da218e649d1b5ac3d67443ae77caf87">ResamplingQuality</a> newQuality)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the quality that will be used when resampling images.  <a href="#a0f8160f9b0a6866e40cf1a2b45c3b892"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ab754b6a67c6964be2d27b1ba82bdae56">drawImageAt</a> (const <a class="el" href="classImage.html">Image</a> &amp;imageToDraw, int topLeftX, int topLeftY, bool fillAlphaChannelWithCurrentBrush=false) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws an image.  <a href="#ab754b6a67c6964be2d27b1ba82bdae56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a6e09218805a3eb3f7d4973433647d0e9">drawImage</a> (const <a class="el" href="classImage.html">Image</a> &amp;imageToDraw, int destX, int destY, int destWidth, int destHeight, int sourceX, int sourceY, int sourceWidth, int sourceHeight, bool fillAlphaChannelWithCurrentBrush=false) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws part of an image, rescaling it to fit in a given target region.  <a href="#a6e09218805a3eb3f7d4973433647d0e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a79c4f544cd7fcada2be7d24691e157a3">drawImageTransformed</a> (const <a class="el" href="classImage.html">Image</a> &amp;imageToDraw, const <a class="el" href="classAffineTransform.html">AffineTransform</a> &amp;transform, bool fillAlphaChannelWithCurrentBrush=false) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws an image, having applied an affine transform to it.  <a href="#a79c4f544cd7fcada2be7d24691e157a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a980e4beef03333ee1ec1ca7b7963ad63">drawImageWithin</a> (const <a class="el" href="classImage.html">Image</a> &amp;imageToDraw, int destX, int destY, int destWidth, int destHeight, const <a class="el" href="classRectanglePlacement.html">RectanglePlacement</a> &amp;placementWithinTarget, bool fillAlphaChannelWithCurrentBrush=false) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws an image to fit within a designated rectangle.  <a href="#a980e4beef03333ee1ec1ca7b7963ad63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRectangle.html">Rectangle</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a34942cbdbd743d7fd332c218ea7e4c5d">getClipBounds</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the bounding box for the current clipping region.  <a href="#a34942cbdbd743d7fd332c218ea7e4c5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a0a91a1c322713e070d8fd42796854340">clipRegionIntersects</a> (const <a class="el" href="classRectangle.html">Rectangle</a>&lt; int &gt; &amp;area) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a rectangle overlaps the context's clipping region.  <a href="#a0a91a1c322713e070d8fd42796854340"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ad97e058fcff2bc0e634eacc4ef1d7a5f">reduceClipRegion</a> (int x, int y, int width, int height)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects the current clipping region with another region.  <a href="#ad97e058fcff2bc0e634eacc4ef1d7a5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a97cba43cb492f57590b5f211e590e38f">reduceClipRegion</a> (const <a class="el" href="classRectangle.html">Rectangle</a>&lt; int &gt; &amp;area)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects the current clipping region with another region.  <a href="#a97cba43cb492f57590b5f211e590e38f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ae30c76ed849ef8a987cb98191e0668e1">reduceClipRegion</a> (const <a class="el" href="classRectangleList.html">RectangleList</a> &amp;clipRegion)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects the current clipping region with a rectangle list region.  <a href="#ae30c76ed849ef8a987cb98191e0668e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a01d830805b335f8cdf52fadd00bd0d30">reduceClipRegion</a> (const <a class="el" href="classPath.html">Path</a> &amp;path, const <a class="el" href="classAffineTransform.html">AffineTransform</a> &amp;transform=<a class="el" href="classAffineTransform.html#a2173017e6300f667a23467505ca36276">AffineTransform::identity</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects the current clipping region with a path.  <a href="#a01d830805b335f8cdf52fadd00bd0d30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a735b5096ea063020134fdf1c570dec9a">reduceClipRegion</a> (const <a class="el" href="classImage.html">Image</a> &amp;image, const <a class="el" href="classAffineTransform.html">AffineTransform</a> &amp;transform)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects the current clipping region with an image's alpha-channel.  <a href="#a735b5096ea063020134fdf1c570dec9a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a9ff97378305763a38f4a99bc638a8824">excludeClipRegion</a> (const <a class="el" href="classRectangle.html">Rectangle</a>&lt; int &gt; &amp;rectangleToExclude)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Excludes a rectangle to stop it being drawn into.  <a href="#a9ff97378305763a38f4a99bc638a8824"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a6ae806601e19bc1631085d6e2a7f5d74">isClipEmpty</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if no drawing can be done because the clip region is zero.  <a href="#a6ae806601e19bc1631085d6e2a7f5d74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ab4df35938684890f7adac0439e900ca8">saveState</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the current graphics state on an internal stack.  <a href="#ab4df35938684890f7adac0439e900ca8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ac724e99c9a7bcd8b2987a484e269a368">restoreState</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores a graphics state that was previously saved with <a class="el" href="classGraphics.html#ab4df35938684890f7adac0439e900ca8" title="Saves the current graphics state on an internal stack.">saveState()</a>.  <a href="#ac724e99c9a7bcd8b2987a484e269a368"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ab8d8ee1c6bb810074eff904fd3c21fc4">beginTransparencyLayer</a> (float layerOpacity)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins rendering to an off-screen bitmap which will later be flattened onto the current context with the given opacity.  <a href="#ab8d8ee1c6bb810074eff904fd3c21fc4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ae6b36ef8295dd83d33287a328e88ef9c">endTransparencyLayer</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Completes a drawing operation to a temporary semi-transparent buffer.  <a href="#ae6b36ef8295dd83d33287a328e88ef9c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a9f6c05af33aefe49851d0d1eb9294bea">setOrigin</a> (int newOriginX, int newOriginY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the position of the context's origin.  <a href="#a9f6c05af33aefe49851d0d1eb9294bea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a7d9d400fdb96d3c6bbb640fb94b54d06">addTransform</a> (const <a class="el" href="classAffineTransform.html">AffineTransform</a> &amp;transform)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a transformation which will be performed on all the graphics operations that the context subsequently performs.  <a href="#a7d9d400fdb96d3c6bbb640fb94b54d06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ab8b7cd49bf1ff738c5ff848727e3bc75">resetToDefaultState</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the current colour, brush, and font to default settings.  <a href="#ab8b7cd49bf1ff738c5ff848727e3bc75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ae584e8878455891d9010addb384425cd">isVectorDevice</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this context is drawing to a vector-based device, such as a printer.  <a href="#ae584e8878455891d9010addb384425cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ac2f451095caee3a7262f135dfd9ed93d">Graphics</a> (<a class="el" href="classLowLevelGraphicsContext.html">LowLevelGraphicsContext</a> *internalContext) noexcept</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a graphics that uses a given low-level renderer.  <a href="#ac2f451095caee3a7262f135dfd9ed93d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLowLevelGraphicsContext.html">LowLevelGraphicsContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a56d2788fe6978ee9da3b58864767e74a">getInternalContext</a> () const noexcept</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A graphics context, used for drawing a component or image. </p>
<p>When a <a class="el" href="classComponent.html" title="The base class for all JUCE user-interface objects.">Component</a> needs painting, a <a class="el" href="classGraphics.html" title="A graphics context, used for drawing a component or image.">Graphics</a> context is passed to its <a class="el" href="classComponent.html#a7cf1862f4af5909ea72827898114a182" title="Components can override this method to draw their content.">Component::paint()</a> method, and this you then call methods within this object to actually draw the component's content.</p>
<p>A <a class="el" href="classGraphics.html" title="A graphics context, used for drawing a component or image.">Graphics</a> can also be created from an image, to allow drawing directly onto that image.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classComponent.html#a7cf1862f4af5909ea72827898114a182" title="Components can override this method to draw their content.">Component::paint</a> </dd></dl>
</div><hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a5da218e649d1b5ac3d67443ae77caf87"></a><!-- doxytag: member="Graphics::ResamplingQuality" ref="a5da218e649d1b5ac3d67443ae77caf87" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classGraphics.html#a5da218e649d1b5ac3d67443ae77caf87">Graphics::ResamplingQuality</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Types of rendering quality that can be specified when drawing images. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>blendImage, <a class="el" href="classGraphics.html#a0f8160f9b0a6866e40cf1a2b45c3b892" title="Changes the quality that will be used when resampling images.">Graphics::setImageResamplingQuality</a> </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a5da218e649d1b5ac3d67443ae77caf87a4eb9cfa2e544befd2d50708e3316b28e"></a><!-- doxytag: member="lowResamplingQuality" ref="a5da218e649d1b5ac3d67443ae77caf87a4eb9cfa2e544befd2d50708e3316b28e" args="" -->lowResamplingQuality</em>&nbsp;</td><td>
<p>Just uses a nearest-neighbour algorithm for resampling. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5da218e649d1b5ac3d67443ae77caf87a5d8dfbf84457e91eb309b1402562f2af"></a><!-- doxytag: member="mediumResamplingQuality" ref="a5da218e649d1b5ac3d67443ae77caf87a5d8dfbf84457e91eb309b1402562f2af" args="" -->mediumResamplingQuality</em>&nbsp;</td><td>
<p>Uses bilinear interpolation for upsampling and area-averaging for downsampling. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5da218e649d1b5ac3d67443ae77caf87ae3c4b3cdf28f0aefc035977522675e8e"></a><!-- doxytag: member="highResamplingQuality" ref="a5da218e649d1b5ac3d67443ae77caf87ae3c4b3cdf28f0aefc035977522675e8e" args="" -->highResamplingQuality</em>&nbsp;</td><td>
<p>Uses bicubic interpolation for upsampling and area-averaging for downsampling. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ada6375a2e6bf68758a2191acb4d62c65"></a><!-- doxytag: member="Graphics::Graphics" ref="ada6375a2e6bf68758a2191acb4d62c65" args="(const Image &amp;imageToDrawOnto)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraphics.html#ada6375a2e6bf68758a2191acb4d62c65">Graphics::Graphics</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classImage.html">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>imageToDrawOnto</em></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a <a class="el" href="classGraphics.html" title="A graphics context, used for drawing a component or image.">Graphics</a> object to draw directly onto the given image. </p>
<p>The graphics object that is created will be set up to draw onto the image, with the context's clipping area being the entire size of the image, and its origin being the image's origin. To draw into a subsection of an image, use the <a class="el" href="classGraphics.html#ad97e058fcff2bc0e634eacc4ef1d7a5f" title="Intersects the current clipping region with another region.">reduceClipRegion()</a> and <a class="el" href="classGraphics.html#a9f6c05af33aefe49851d0d1eb9294bea" title="Moves the position of the context&#39;s origin.">setOrigin()</a> methods.</p>
<p>Obviously you shouldn't delete the image before this context is deleted. </p>

</div>
</div>
<a class="anchor" id="a7841c9a961ac9bca33bd30ddf8066cdb"></a><!-- doxytag: member="Graphics::~Graphics" ref="a7841c9a961ac9bca33bd30ddf8066cdb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraphics.html#a7841c9a961ac9bca33bd30ddf8066cdb">Graphics::~Graphics</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<a class="anchor" id="ac2f451095caee3a7262f135dfd9ed93d"></a><!-- doxytag: member="Graphics::Graphics" ref="ac2f451095caee3a7262f135dfd9ed93d" args="(LowLevelGraphicsContext *internalContext) noexcept" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraphics.html#ada6375a2e6bf68758a2191acb4d62c65">Graphics::Graphics</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLowLevelGraphicsContext.html">LowLevelGraphicsContext</a> *&#160;</td>
          <td class="paramname"><em>internalContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a graphics that uses a given low-level renderer. </p>
<p>For internal use only. NB. The context will NOT be deleted by this object when it is deleted. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af17c43bb97e6822aa4b7b8a8adc40b99"></a><!-- doxytag: member="Graphics::setColour" ref="af17c43bb97e6822aa4b7b8a8adc40b99" args="(const Colour &amp;newColour)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#af17c43bb97e6822aa4b7b8a8adc40b99">Graphics::setColour</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classColour.html">Colour</a> &amp;&#160;</td>
          <td class="paramname"><em>newColour</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the current drawing colour. </p>
<p>This sets the colour that will now be used for drawing operations - it also sets the opacity to that of the colour passed-in.</p>
<p>If a brush is being used when this method is called, the brush will be deselected, and any subsequent drawing will be done with a solid colour brush instead.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classGraphics.html#a1ce91a31ec1258a73ace93b6c337dbb2" title="Changes the opacity to use with the current colour.">setOpacity</a> </dd></dl>

<p>Referenced by <a class="el" href="classLassoComponent.html#aa2b05e6a36b1ab1f9bbdc52d27bb1c08">LassoComponent&lt; SelectableItemType &gt;::paint()</a>.</p>

</div>
</div>
<a class="anchor" id="a1ce91a31ec1258a73ace93b6c337dbb2"></a><!-- doxytag: member="Graphics::setOpacity" ref="a1ce91a31ec1258a73ace93b6c337dbb2" args="(float newOpacity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a1ce91a31ec1258a73ace93b6c337dbb2">Graphics::setOpacity</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>newOpacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the opacity to use with the current colour. </p>
<p>If a solid colour is being used for drawing, this changes its opacity to this new value (i.e. it doesn't multiply the colour's opacity by this amount).</p>
<p>If a gradient is being used, this will have no effect on it.</p>
<p>A value of 0.0 is completely transparent, 1.0 is completely opaque. </p>

</div>
</div>
<a class="anchor" id="a57478bc2496ebb84696e5ba64b455965"></a><!-- doxytag: member="Graphics::setGradientFill" ref="a57478bc2496ebb84696e5ba64b455965" args="(const ColourGradient &amp;gradient)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a57478bc2496ebb84696e5ba64b455965">Graphics::setGradientFill</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classColourGradient.html">ColourGradient</a> &amp;&#160;</td>
          <td class="paramname"><em>gradient</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the context to use a gradient for its fill pattern. </p>

</div>
</div>
<a class="anchor" id="a675cd4c4715165f0a0aec0bd8c3fe390"></a><!-- doxytag: member="Graphics::setTiledImageFill" ref="a675cd4c4715165f0a0aec0bd8c3fe390" args="(const Image &amp;imageToUse, int anchorX, int anchorY, float opacity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a675cd4c4715165f0a0aec0bd8c3fe390">Graphics::setTiledImageFill</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classImage.html">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>imageToUse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>anchorX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>anchorY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the context to use a tiled image pattern for filling. </p>
<p>Make sure that you don't delete this image while it's still being used by this context! </p>

</div>
</div>
<a class="anchor" id="a763ea233d7b7c8e45e33c7ea8030ff48"></a><!-- doxytag: member="Graphics::setFillType" ref="a763ea233d7b7c8e45e33c7ea8030ff48" args="(const FillType &amp;newFill)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a763ea233d7b7c8e45e33c7ea8030ff48">Graphics::setFillType</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFillType.html">FillType</a> &amp;&#160;</td>
          <td class="paramname"><em>newFill</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the current fill settings. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classGraphics.html#af17c43bb97e6822aa4b7b8a8adc40b99" title="Changes the current drawing colour.">setColour</a>, <a class="el" href="classGraphics.html#a57478bc2496ebb84696e5ba64b455965" title="Sets the context to use a gradient for its fill pattern.">setGradientFill</a>, <a class="el" href="classGraphics.html#a675cd4c4715165f0a0aec0bd8c3fe390" title="Sets the context to use a tiled image pattern for filling.">setTiledImageFill</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1fbdb321975d90c45243027a61ac2be9"></a><!-- doxytag: member="Graphics::setFont" ref="a1fbdb321975d90c45243027a61ac2be9" args="(const Font &amp;newFont)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a1fbdb321975d90c45243027a61ac2be9">Graphics::setFont</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFont.html">Font</a> &amp;&#160;</td>
          <td class="paramname"><em>newFont</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the font to use for subsequent text-drawing functions. </p>
<p>Note there's also a setFont (float, int) method to quickly change the size and style of the current font.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classGraphics.html#ade61955c11b56c91232b350dbfbf1b81" title="Draws a one-line text string.">drawSingleLineText</a>, <a class="el" href="classGraphics.html#a37c017a9d2f32bcd677f61f5de97ab9a" title="Draws text across multiple lines.">drawMultiLineText</a>, <a class="el" href="classGraphics.html#a837821b4bab764d76df560350e069b45" title="Renders a string of text as a vector path.">drawTextAsPath</a>, <a class="el" href="classGraphics.html#aa03c871748cf584b548663b79da7926c" title="Draws a line of text within a specified rectangle.">drawText</a>, <a class="el" href="classGraphics.html#ad2c56e11c42bc7404233b9a23e939ede" title="Tries to draw a text string inside a given space.">drawFittedText</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af6e07de35e7d2777f9152633b0932fbd"></a><!-- doxytag: member="Graphics::setFont" ref="af6e07de35e7d2777f9152633b0932fbd" args="(float newFontHeight, int fontStyleFlags=Font::plain)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a1fbdb321975d90c45243027a61ac2be9">Graphics::setFont</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>newFontHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fontStyleFlags</em> = <code><a class="el" href="classFont.html#a52a35b5dc1e6f782e25283c9283bae4fa99039e6bb438434f9bccde132132dd99">Font::plain</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the size and style of the currently-selected font. </p>
<p>This is a convenient shortcut that changes the context's current font to a different size or style. The typeface won't be changed.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classFont.html" title="Represents a particular font, including its size, style, etc.">Font</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abb972f0d801630b6e02d335cfa9da28a"></a><!-- doxytag: member="Graphics::getCurrentFont" ref="abb972f0d801630b6e02d335cfa9da28a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFont.html">Font</a> <a class="el" href="classGraphics.html#abb972f0d801630b6e02d335cfa9da28a">Graphics::getCurrentFont</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the currently selected font. </p>

</div>
</div>
<a class="anchor" id="ade61955c11b56c91232b350dbfbf1b81"></a><!-- doxytag: member="Graphics::drawSingleLineText" ref="ade61955c11b56c91232b350dbfbf1b81" args="(const String &amp;text, int startX, int baselineY, const Justification &amp;justification=Justification::left) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#ade61955c11b56c91232b350dbfbf1b81">Graphics::drawSingleLineText</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classString.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baselineY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classJustification.html">Justification</a> &amp;&#160;</td>
          <td class="paramname"><em>justification</em> = <code><a class="el" href="classJustification.html#a4b9db354585c335c96baecf1a14c2db5a56156bb2892e32febf8011af9c5da653">Justification::left</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws a one-line text string. </p>
<p>This will use the current colour (or brush) to fill the text. The font is the last one specified by <a class="el" href="classGraphics.html#a1fbdb321975d90c45243027a61ac2be9" title="Changes the font to use for subsequent text-drawing functions.">setFont()</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>the string to draw </td></tr>
    <tr><td class="paramname">startX</td><td>the position to draw the left-hand edge of the text </td></tr>
    <tr><td class="paramname">baselineY</td><td>the position of the text's baseline </td></tr>
    <tr><td class="paramname">justification</td><td>the horizontal flags indicate which end of the text string is anchored at the specified point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classGraphics.html#a37c017a9d2f32bcd677f61f5de97ab9a" title="Draws text across multiple lines.">drawMultiLineText</a>, <a class="el" href="classGraphics.html#aa03c871748cf584b548663b79da7926c" title="Draws a line of text within a specified rectangle.">drawText</a>, <a class="el" href="classGraphics.html#ad2c56e11c42bc7404233b9a23e939ede" title="Tries to draw a text string inside a given space.">drawFittedText</a>, <a class="el" href="classGlyphArrangement.html#a0ace103d7c4b6600dcea7aff1f26811d" title="Appends a line of text to the arrangement.">GlyphArrangement::addLineOfText</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a37c017a9d2f32bcd677f61f5de97ab9a"></a><!-- doxytag: member="Graphics::drawMultiLineText" ref="a37c017a9d2f32bcd677f61f5de97ab9a" args="(const String &amp;text, int startX, int baselineY, int maximumLineWidth) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a37c017a9d2f32bcd677f61f5de97ab9a">Graphics::drawMultiLineText</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classString.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baselineY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maximumLineWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws text across multiple lines. </p>
<p>This will break the text onto a new line where there's a new-line or carriage-return character, or at a word-boundary when the text becomes wider than the size specified by the maximumLineWidth parameter.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classGraphics.html#a1fbdb321975d90c45243027a61ac2be9" title="Changes the font to use for subsequent text-drawing functions.">setFont</a>, <a class="el" href="classGraphics.html#ade61955c11b56c91232b350dbfbf1b81" title="Draws a one-line text string.">drawSingleLineText</a>, <a class="el" href="classGraphics.html#ad2c56e11c42bc7404233b9a23e939ede" title="Tries to draw a text string inside a given space.">drawFittedText</a>, <a class="el" href="classGlyphArrangement.html#a5cc600b28d93cb972baf14d3be08859f" title="Adds some multi-line text, breaking lines at word-boundaries if they are too wide.">GlyphArrangement::addJustifiedText</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a837821b4bab764d76df560350e069b45"></a><!-- doxytag: member="Graphics::drawTextAsPath" ref="a837821b4bab764d76df560350e069b45" args="(const String &amp;text, const AffineTransform &amp;transform) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a837821b4bab764d76df560350e069b45">Graphics::drawTextAsPath</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classString.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineTransform.html">AffineTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Renders a string of text as a vector path. </p>
<p>This allows a string to be transformed with an arbitrary <a class="el" href="classAffineTransform.html" title="Represents a 2D affine-transformation matrix.">AffineTransform</a> and rendered using the current colour/brush. It's much slower than the normal text methods but more accurate.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classGraphics.html#a1fbdb321975d90c45243027a61ac2be9" title="Changes the font to use for subsequent text-drawing functions.">setFont</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa03c871748cf584b548663b79da7926c"></a><!-- doxytag: member="Graphics::drawText" ref="aa03c871748cf584b548663b79da7926c" args="(const String &amp;text, int x, int y, int width, int height, const Justification &amp;justificationType, bool useEllipsesIfTooBig) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#aa03c871748cf584b548663b79da7926c">Graphics::drawText</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classString.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classJustification.html">Justification</a> &amp;&#160;</td>
          <td class="paramname"><em>justificationType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useEllipsesIfTooBig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws a line of text within a specified rectangle. </p>
<p>The text will be positioned within the rectangle based on the justification flags passed-in. If the string is too long to fit inside the rectangle, it will either be truncated or will have ellipsis added to its end (if the useEllipsesIfTooBig flag is true).</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classGraphics.html#ade61955c11b56c91232b350dbfbf1b81" title="Draws a one-line text string.">drawSingleLineText</a>, <a class="el" href="classGraphics.html#ad2c56e11c42bc7404233b9a23e939ede" title="Tries to draw a text string inside a given space.">drawFittedText</a>, <a class="el" href="classGraphics.html#a37c017a9d2f32bcd677f61f5de97ab9a" title="Draws text across multiple lines.">drawMultiLineText</a>, <a class="el" href="classGlyphArrangement.html#a5cc600b28d93cb972baf14d3be08859f" title="Adds some multi-line text, breaking lines at word-boundaries if they are too wide.">GlyphArrangement::addJustifiedText</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad2c56e11c42bc7404233b9a23e939ede"></a><!-- doxytag: member="Graphics::drawFittedText" ref="ad2c56e11c42bc7404233b9a23e939ede" args="(const String &amp;text, int x, int y, int width, int height, const Justification &amp;justificationFlags, int maximumNumberOfLines, float minimumHorizontalScale=0.7f) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#ad2c56e11c42bc7404233b9a23e939ede">Graphics::drawFittedText</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classString.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classJustification.html">Justification</a> &amp;&#160;</td>
          <td class="paramname"><em>justificationFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maximumNumberOfLines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minimumHorizontalScale</em> = <code>0.7f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to draw a text string inside a given space. </p>
<p>This does its best to make the given text readable within the specified rectangle, so it useful for labelling things.</p>
<p>If the text is too big, it'll be squashed horizontally or broken over multiple lines if the maximumLinesToUse value allows this. If the text just won't fit into the space, it'll cram as much as possible in there, and put some ellipsis at the end to show that it's been truncated.</p>
<p>A <a class="el" href="classJustification.html" title="Represents a type of justification to be used when positioning graphical items.">Justification</a> parameter lets you specify how the text is laid out within the rectangle, both horizontally and vertically.</p>
<p>The minimumHorizontalScale parameter specifies how much the text can be squashed horizontally to try to squeeze it into the space. If you don't want any horizontal scaling to occur, you can set this value to 1.0f.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classGlyphArrangement.html#a18cfbfb3481a8f6d498e58be4f1c438b" title="Tries to fit some text withing a given space.">GlyphArrangement::addFittedText</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a516a7795e6e0c6c70eb982a83ea0b8c3"></a><!-- doxytag: member="Graphics::fillAll" ref="a516a7795e6e0c6c70eb982a83ea0b8c3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a516a7795e6e0c6c70eb982a83ea0b8c3">Graphics::fillAll</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills the context's entire clip region with the current colour or brush. </p>
<p>(See also the fillAll (const <a class="el" href="classColour.html" title="Represents a colour, also including a transparency value.">Colour</a>&amp;) method which is a quick way of filling it with a given colour). </p>

<p>Referenced by <a class="el" href="classLassoComponent.html#aa2b05e6a36b1ab1f9bbdc52d27bb1c08">LassoComponent&lt; SelectableItemType &gt;::paint()</a>.</p>

</div>
</div>
<a class="anchor" id="a29e9bc174cf54be0f423172e24d5cf78"></a><!-- doxytag: member="Graphics::fillAll" ref="a29e9bc174cf54be0f423172e24d5cf78" args="(const Colour &amp;colourToUse) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a516a7795e6e0c6c70eb982a83ea0b8c3">Graphics::fillAll</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classColour.html">Colour</a> &amp;&#160;</td>
          <td class="paramname"><em>colourToUse</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills the context's entire clip region with a given colour. </p>
<p>This leaves the context's current colour and brush unchanged, it just uses the specified colour temporarily. </p>

</div>
</div>
<a class="anchor" id="ac2202ef993b53d77d8646ed4ce3ea9d1"></a><!-- doxytag: member="Graphics::fillRect" ref="ac2202ef993b53d77d8646ed4ce3ea9d1" args="(int x, int y, int width, int height) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#ac2202ef993b53d77d8646ed4ce3ea9d1">Graphics::fillRect</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a rectangle with the current colour or brush. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classGraphics.html#a28baf90f8e11ec6f96c349f45e09a9d0" title="Draws four lines to form a rectangular outline, using the current colour or brush.">drawRect</a>, <a class="el" href="classGraphics.html#a1049a2dae8a1ae3e5e57238f2fd36a84" title="Uses the current colour or brush to fill a rectangle with rounded corners.">fillRoundedRectangle</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9ff78524c757a302ad8b9cbc4c7ba851"></a><!-- doxytag: member="Graphics::fillRect" ref="a9ff78524c757a302ad8b9cbc4c7ba851" args="(const Rectangle&lt; int &gt; &amp;rectangle) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#ac2202ef993b53d77d8646ed4ce3ea9d1">Graphics::fillRect</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRectangle.html">Rectangle</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>rectangle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a rectangle with the current colour or brush. </p>

</div>
</div>
<a class="anchor" id="a018bffc13a318cb5e59d29b258313b8b"></a><!-- doxytag: member="Graphics::fillRect" ref="a018bffc13a318cb5e59d29b258313b8b" args="(float x, float y, float width, float height) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#ac2202ef993b53d77d8646ed4ce3ea9d1">Graphics::fillRect</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a rectangle with the current colour or brush. </p>
<p>This uses sub-pixel positioning so is slower than the fillRect method which takes integer co-ordinates. </p>

</div>
</div>
<a class="anchor" id="a1049a2dae8a1ae3e5e57238f2fd36a84"></a><!-- doxytag: member="Graphics::fillRoundedRectangle" ref="a1049a2dae8a1ae3e5e57238f2fd36a84" args="(float x, float y, float width, float height, float cornerSize) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a1049a2dae8a1ae3e5e57238f2fd36a84">Graphics::fillRoundedRectangle</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cornerSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uses the current colour or brush to fill a rectangle with rounded corners. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classGraphics.html#a78541e36136eb040c4b8c81d4b8db8dd" title="Uses the current colour or brush to draw the outline of a rectangle with rounded corners.">drawRoundedRectangle</a>, <a class="el" href="classPath.html#a501f83b0e323fe86d33c047f83451065" title="Adds a rectangle with rounded corners to the path.">Path::addRoundedRectangle</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afc06f32c228086e55876184176314bd1"></a><!-- doxytag: member="Graphics::fillRoundedRectangle" ref="afc06f32c228086e55876184176314bd1" args="(const Rectangle&lt; float &gt; &amp;rectangle, float cornerSize) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a1049a2dae8a1ae3e5e57238f2fd36a84">Graphics::fillRoundedRectangle</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRectangle.html">Rectangle</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>rectangle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cornerSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uses the current colour or brush to fill a rectangle with rounded corners. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classGraphics.html#a78541e36136eb040c4b8c81d4b8db8dd" title="Uses the current colour or brush to draw the outline of a rectangle with rounded corners.">drawRoundedRectangle</a>, <a class="el" href="classPath.html#a501f83b0e323fe86d33c047f83451065" title="Adds a rectangle with rounded corners to the path.">Path::addRoundedRectangle</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a359717e34bed0f5dfd2f3004b3cea19f"></a><!-- doxytag: member="Graphics::fillCheckerBoard" ref="a359717e34bed0f5dfd2f3004b3cea19f" args="(const Rectangle&lt; int &gt; &amp;area, int checkWidth, int checkHeight, const Colour &amp;colour1, const Colour &amp;colour2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a359717e34bed0f5dfd2f3004b3cea19f">Graphics::fillCheckerBoard</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRectangle.html">Rectangle</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>checkWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>checkHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classColour.html">Colour</a> &amp;&#160;</td>
          <td class="paramname"><em>colour1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classColour.html">Colour</a> &amp;&#160;</td>
          <td class="paramname"><em>colour2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a rectangle with a checkerboard pattern, alternating between two colours. </p>

</div>
</div>
<a class="anchor" id="a28baf90f8e11ec6f96c349f45e09a9d0"></a><!-- doxytag: member="Graphics::drawRect" ref="a28baf90f8e11ec6f96c349f45e09a9d0" args="(int x, int y, int width, int height, int lineThickness=1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a28baf90f8e11ec6f96c349f45e09a9d0">Graphics::drawRect</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineThickness</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws four lines to form a rectangular outline, using the current colour or brush. </p>
<p>The lines are drawn inside the given rectangle, and greater line thicknesses extend inwards.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classGraphics.html#ac2202ef993b53d77d8646ed4ce3ea9d1" title="Fills a rectangle with the current colour or brush.">fillRect</a> </dd></dl>

<p>Referenced by <a class="el" href="classLassoComponent.html#aa2b05e6a36b1ab1f9bbdc52d27bb1c08">LassoComponent&lt; SelectableItemType &gt;::paint()</a>.</p>

</div>
</div>
<a class="anchor" id="a7b8a15c73c5d797cd169852224236f4f"></a><!-- doxytag: member="Graphics::drawRect" ref="a7b8a15c73c5d797cd169852224236f4f" args="(float x, float y, float width, float height, float lineThickness=1.0f) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a28baf90f8e11ec6f96c349f45e09a9d0">Graphics::drawRect</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lineThickness</em> = <code>1.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws four lines to form a rectangular outline, using the current colour or brush. </p>
<p>The lines are drawn inside the given rectangle, and greater line thicknesses extend inwards.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classGraphics.html#ac2202ef993b53d77d8646ed4ce3ea9d1" title="Fills a rectangle with the current colour or brush.">fillRect</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a88e7c28b48c3f2e9e2c9df7d2571908f"></a><!-- doxytag: member="Graphics::drawRect" ref="a88e7c28b48c3f2e9e2c9df7d2571908f" args="(const Rectangle&lt; int &gt; &amp;rectangle, int lineThickness=1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a28baf90f8e11ec6f96c349f45e09a9d0">Graphics::drawRect</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRectangle.html">Rectangle</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>rectangle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineThickness</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws four lines to form a rectangular outline, using the current colour or brush. </p>
<p>The lines are drawn inside the given rectangle, and greater line thicknesses extend inwards.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classGraphics.html#ac2202ef993b53d77d8646ed4ce3ea9d1" title="Fills a rectangle with the current colour or brush.">fillRect</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a78541e36136eb040c4b8c81d4b8db8dd"></a><!-- doxytag: member="Graphics::drawRoundedRectangle" ref="a78541e36136eb040c4b8c81d4b8db8dd" args="(float x, float y, float width, float height, float cornerSize, float lineThickness) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a78541e36136eb040c4b8c81d4b8db8dd">Graphics::drawRoundedRectangle</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cornerSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lineThickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uses the current colour or brush to draw the outline of a rectangle with rounded corners. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classGraphics.html#a1049a2dae8a1ae3e5e57238f2fd36a84" title="Uses the current colour or brush to fill a rectangle with rounded corners.">fillRoundedRectangle</a>, <a class="el" href="classPath.html#a501f83b0e323fe86d33c047f83451065" title="Adds a rectangle with rounded corners to the path.">Path::addRoundedRectangle</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a91706e86b7120523346fee8f2161d48f"></a><!-- doxytag: member="Graphics::drawRoundedRectangle" ref="a91706e86b7120523346fee8f2161d48f" args="(const Rectangle&lt; float &gt; &amp;rectangle, float cornerSize, float lineThickness) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a78541e36136eb040c4b8c81d4b8db8dd">Graphics::drawRoundedRectangle</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRectangle.html">Rectangle</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>rectangle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cornerSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lineThickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uses the current colour or brush to draw the outline of a rectangle with rounded corners. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classGraphics.html#a1049a2dae8a1ae3e5e57238f2fd36a84" title="Uses the current colour or brush to fill a rectangle with rounded corners.">fillRoundedRectangle</a>, <a class="el" href="classPath.html#a501f83b0e323fe86d33c047f83451065" title="Adds a rectangle with rounded corners to the path.">Path::addRoundedRectangle</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9785e9e0d63e8576db415decc7f5b2cd"></a><!-- doxytag: member="Graphics::drawBevel" ref="a9785e9e0d63e8576db415decc7f5b2cd" args="(int x, int y, int width, int height, int bevelThickness, const Colour &amp;topLeftColour=Colours::white, const Colour &amp;bottomRightColour=Colours::black, bool useGradient=true, bool sharpEdgeOnOutside=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a9785e9e0d63e8576db415decc7f5b2cd">Graphics::drawBevel</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bevelThickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classColour.html">Colour</a> &amp;&#160;</td>
          <td class="paramname"><em>topLeftColour</em> = <code><a class="el" href="classColours.html#a9e57055bbdf8261e776d2ea8bb44514a">Colours::white</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classColour.html">Colour</a> &amp;&#160;</td>
          <td class="paramname"><em>bottomRightColour</em> = <code><a class="el" href="classColours.html#aad3910013bf00a80305c082284cd5ee2">Colours::black</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useGradient</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sharpEdgeOnOutside</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws a 3D raised (or indented) bevel using two colours. </p>
<p>The bevel is drawn inside the given rectangle, and greater bevel thicknesses extend inwards.</p>
<p>The top-left colour is used for the top- and left-hand edges of the bevel; the bottom-right colour is used for the bottom- and right-hand edges.</p>
<p>If useGradient is true, then the bevel fades out to make it look more curved and less angular. If sharpEdgeOnOutside is true, the outside of the bevel is sharp, and it fades towards the centre; if sharpEdgeOnOutside is false, then the centre edges are sharp and it fades towards the outside. </p>

</div>
</div>
<a class="anchor" id="a69e70db1afc03d58f9055f8f45d8e5d1"></a><!-- doxytag: member="Graphics::setPixel" ref="a69e70db1afc03d58f9055f8f45d8e5d1" args="(int x, int y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a69e70db1afc03d58f9055f8f45d8e5d1">Graphics::setPixel</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws a pixel using the current colour or brush. </p>

</div>
</div>
<a class="anchor" id="ab6fdfd1cb32b32d52b6b30df36321f70"></a><!-- doxytag: member="Graphics::fillEllipse" ref="ab6fdfd1cb32b32d52b6b30df36321f70" args="(float x, float y, float width, float height) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#ab6fdfd1cb32b32d52b6b30df36321f70">Graphics::fillEllipse</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills an ellipse with the current colour or brush. </p>
<p>The ellipse is drawn to fit inside the given rectangle.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classGraphics.html#ac88110d5407539aa1be841a89d5170b0" title="Draws an elliptical stroke using the current colour or brush.">drawEllipse</a>, <a class="el" href="classPath.html#a7514c5eaa928b64121490a7f0ce3088c" title="Adds an ellipse to the path.">Path::addEllipse</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac88110d5407539aa1be841a89d5170b0"></a><!-- doxytag: member="Graphics::drawEllipse" ref="ac88110d5407539aa1be841a89d5170b0" args="(float x, float y, float width, float height, float lineThickness) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#ac88110d5407539aa1be841a89d5170b0">Graphics::drawEllipse</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lineThickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws an elliptical stroke using the current colour or brush. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classGraphics.html#ab6fdfd1cb32b32d52b6b30df36321f70" title="Fills an ellipse with the current colour or brush.">fillEllipse</a>, <a class="el" href="classPath.html#a7514c5eaa928b64121490a7f0ce3088c" title="Adds an ellipse to the path.">Path::addEllipse</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0911bf63fd6c0d3e35b2b701fcbc7728"></a><!-- doxytag: member="Graphics::drawLine" ref="a0911bf63fd6c0d3e35b2b701fcbc7728" args="(float startX, float startY, float endX, float endY) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a0911bf63fd6c0d3e35b2b701fcbc7728">Graphics::drawLine</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>startX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>startY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>endX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>endY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws a line between two points. </p>
<p>The line is 1 pixel wide and drawn with the current colour or brush. </p>

</div>
</div>
<a class="anchor" id="a664643f9fef3c8b37b0620c28ec4bb76"></a><!-- doxytag: member="Graphics::drawLine" ref="a664643f9fef3c8b37b0620c28ec4bb76" args="(float startX, float startY, float endX, float endY, float lineThickness) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a0911bf63fd6c0d3e35b2b701fcbc7728">Graphics::drawLine</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>startX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>startY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>endX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>endY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lineThickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws a line between two points with a given thickness. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classPath.html#a93c4d70100bed1ea07518fea36267035" title="Adds a line with a specified thickness.">Path::addLineSegment</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a94cf6a3a058ad1a36dc836b34916ef0d"></a><!-- doxytag: member="Graphics::drawLine" ref="a94cf6a3a058ad1a36dc836b34916ef0d" args="(const Line&lt; float &gt; &amp;line) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a0911bf63fd6c0d3e35b2b701fcbc7728">Graphics::drawLine</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLine.html">Line</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws a line between two points. </p>
<p>The line is 1 pixel wide and drawn with the current colour or brush. </p>

</div>
</div>
<a class="anchor" id="ace7c180c66f119399acb69ad966057e3"></a><!-- doxytag: member="Graphics::drawLine" ref="ace7c180c66f119399acb69ad966057e3" args="(const Line&lt; float &gt; &amp;line, float lineThickness) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a0911bf63fd6c0d3e35b2b701fcbc7728">Graphics::drawLine</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLine.html">Line</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lineThickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws a line between two points with a given thickness. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classPath.html#a93c4d70100bed1ea07518fea36267035" title="Adds a line with a specified thickness.">Path::addLineSegment</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab24a3f2ba3d648285fcad7c97fb8270f"></a><!-- doxytag: member="Graphics::drawDashedLine" ref="ab24a3f2ba3d648285fcad7c97fb8270f" args="(const Line&lt; float &gt; &amp;line, const float *dashLengths, int numDashLengths, float lineThickness=1.0f, int dashIndexToStartFrom=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#ab24a3f2ba3d648285fcad7c97fb8270f">Graphics::drawDashedLine</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLine.html">Line</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>dashLengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numDashLengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lineThickness</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dashIndexToStartFrom</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws a dashed line using a custom set of dash-lengths. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>the line to draw </td></tr>
    <tr><td class="paramname">dashLengths</td><td>a series of lengths to specify the on/off lengths - e.g. { 4, 5, 6, 7 } will draw a line of 4 pixels, skip 5 pixels, draw 6 pixels, skip 7 pixels, and then repeat. </td></tr>
    <tr><td class="paramname">numDashLengths</td><td>the number of elements in the array (this must be an even number). </td></tr>
    <tr><td class="paramname">lineThickness</td><td>the thickness of the line to draw </td></tr>
    <tr><td class="paramname">dashIndexToStartFrom</td><td>the index in the dash-length array to use for the first segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classPathStrokeType.html#a4eca56bfcdc41f774fcde1c8e34b70af" title="Applies this stroke type to a path, creating a dashed line.">PathStrokeType::createDashedStroke</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a042d4f7223a63212ae1d9452e26cbd7a"></a><!-- doxytag: member="Graphics::drawVerticalLine" ref="a042d4f7223a63212ae1d9452e26cbd7a" args="(int x, float top, float bottom) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a042d4f7223a63212ae1d9452e26cbd7a">Graphics::drawVerticalLine</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bottom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws a vertical line of pixels at a given x position. </p>
<p>The x position is an integer, but the top and bottom of the line can be sub-pixel positions, and these will be anti-aliased if necessary.</p>
<p>The bottom parameter must be greater than or equal to the top parameter. </p>

</div>
</div>
<a class="anchor" id="aeea9ba47ff90bb7643038692bf647738"></a><!-- doxytag: member="Graphics::drawHorizontalLine" ref="aeea9ba47ff90bb7643038692bf647738" args="(int y, float left, float right) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#aeea9ba47ff90bb7643038692bf647738">Graphics::drawHorizontalLine</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws a horizontal line of pixels at a given y position. </p>
<p>The y position is an integer, but the left and right ends of the line can be sub-pixel positions, and these will be anti-aliased if necessary.</p>
<p>The right parameter must be greater than or equal to the left parameter. </p>

</div>
</div>
<a class="anchor" id="a129aa4c9dcc137a1c910a2f5ef118fb7"></a><!-- doxytag: member="Graphics::fillPath" ref="a129aa4c9dcc137a1c910a2f5ef118fb7" args="(const Path &amp;path, const AffineTransform &amp;transform=AffineTransform::identity) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a129aa4c9dcc137a1c910a2f5ef118fb7">Graphics::fillPath</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPath.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineTransform.html">AffineTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em> = <code><a class="el" href="classAffineTransform.html#a2173017e6300f667a23467505ca36276">AffineTransform::identity</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a path using the currently selected colour or brush. </p>

</div>
</div>
<a class="anchor" id="a5bd626168d02b83d10123e398da5c5a7"></a><!-- doxytag: member="Graphics::strokePath" ref="a5bd626168d02b83d10123e398da5c5a7" args="(const Path &amp;path, const PathStrokeType &amp;strokeType, const AffineTransform &amp;transform=AffineTransform::identity) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a5bd626168d02b83d10123e398da5c5a7">Graphics::strokePath</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPath.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPathStrokeType.html">PathStrokeType</a> &amp;&#160;</td>
          <td class="paramname"><em>strokeType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineTransform.html">AffineTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em> = <code><a class="el" href="classAffineTransform.html#a2173017e6300f667a23467505ca36276">AffineTransform::identity</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws a path's outline using the currently selected colour or brush. </p>

</div>
</div>
<a class="anchor" id="ab1484b102f99384c443cfb5881d68fa9"></a><!-- doxytag: member="Graphics::drawArrow" ref="ab1484b102f99384c443cfb5881d68fa9" args="(const Line&lt; float &gt; &amp;line, float lineThickness, float arrowheadWidth, float arrowheadLength) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#ab1484b102f99384c443cfb5881d68fa9">Graphics::drawArrow</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLine.html">Line</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lineThickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arrowheadWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arrowheadLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws a line with an arrowhead at its end. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>the line to draw </td></tr>
    <tr><td class="paramname">lineThickness</td><td>the thickness of the line </td></tr>
    <tr><td class="paramname">arrowheadWidth</td><td>the width of the arrow head (perpendicular to the line) </td></tr>
    <tr><td class="paramname">arrowheadLength</td><td>the length of the arrow head (along the length of the line) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0f8160f9b0a6866e40cf1a2b45c3b892"></a><!-- doxytag: member="Graphics::setImageResamplingQuality" ref="a0f8160f9b0a6866e40cf1a2b45c3b892" args="(const ResamplingQuality newQuality)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a0f8160f9b0a6866e40cf1a2b45c3b892">Graphics::setImageResamplingQuality</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGraphics.html#a5da218e649d1b5ac3d67443ae77caf87">ResamplingQuality</a>&#160;</td>
          <td class="paramname"><em>newQuality</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the quality that will be used when resampling images. </p>
<p>By default a <a class="el" href="classGraphics.html" title="A graphics context, used for drawing a component or image.">Graphics</a> object will be set to mediumRenderingQuality.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classGraphics.html#a6e09218805a3eb3f7d4973433647d0e9" title="Draws part of an image, rescaling it to fit in a given target region.">Graphics::drawImage</a>, <a class="el" href="classGraphics.html#a79c4f544cd7fcada2be7d24691e157a3" title="Draws an image, having applied an affine transform to it.">Graphics::drawImageTransformed</a>, <a class="el" href="classGraphics.html#a980e4beef03333ee1ec1ca7b7963ad63" title="Draws an image to fit within a designated rectangle.">Graphics::drawImageWithin</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab754b6a67c6964be2d27b1ba82bdae56"></a><!-- doxytag: member="Graphics::drawImageAt" ref="ab754b6a67c6964be2d27b1ba82bdae56" args="(const Image &amp;imageToDraw, int topLeftX, int topLeftY, bool fillAlphaChannelWithCurrentBrush=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#ab754b6a67c6964be2d27b1ba82bdae56">Graphics::drawImageAt</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classImage.html">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>imageToDraw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>topLeftX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>topLeftY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fillAlphaChannelWithCurrentBrush</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws an image. </p>
<p>This will draw the whole of an image, positioning its top-left corner at the given co-ordinates, and keeping its size the same. This is the simplest image drawing method - the others give more control over the scaling and clipping of the images.</p>
<p>Images are composited using the context's current opacity, so if you don't want it to be drawn semi-transparently, be sure to call setOpacity (1.0f) (or <a class="el" href="classGraphics.html#af17c43bb97e6822aa4b7b8a8adc40b99" title="Changes the current drawing colour.">setColour()</a> with an opaque colour) before drawing images. </p>

</div>
</div>
<a class="anchor" id="a6e09218805a3eb3f7d4973433647d0e9"></a><!-- doxytag: member="Graphics::drawImage" ref="a6e09218805a3eb3f7d4973433647d0e9" args="(const Image &amp;imageToDraw, int destX, int destY, int destWidth, int destHeight, int sourceX, int sourceY, int sourceWidth, int sourceHeight, bool fillAlphaChannelWithCurrentBrush=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a6e09218805a3eb3f7d4973433647d0e9">Graphics::drawImage</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classImage.html">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>imageToDraw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sourceX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sourceY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sourceWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sourceHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fillAlphaChannelWithCurrentBrush</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws part of an image, rescaling it to fit in a given target region. </p>
<p>The specified area of the source image is rescaled and drawn to fill the specifed destination rectangle.</p>
<p>Images are composited using the context's current opacity, so if you don't want it to be drawn semi-transparently, be sure to call setOpacity (1.0f) (or <a class="el" href="classGraphics.html#af17c43bb97e6822aa4b7b8a8adc40b99" title="Changes the current drawing colour.">setColour()</a> with an opaque colour) before drawing images.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">imageToDraw</td><td>the image to overlay </td></tr>
    <tr><td class="paramname">destX</td><td>the left of the destination rectangle </td></tr>
    <tr><td class="paramname">destY</td><td>the top of the destination rectangle </td></tr>
    <tr><td class="paramname">destWidth</td><td>the width of the destination rectangle </td></tr>
    <tr><td class="paramname">destHeight</td><td>the height of the destination rectangle </td></tr>
    <tr><td class="paramname">sourceX</td><td>the left of the rectangle to copy from the source image </td></tr>
    <tr><td class="paramname">sourceY</td><td>the top of the rectangle to copy from the source image </td></tr>
    <tr><td class="paramname">sourceWidth</td><td>the width of the rectangle to copy from the source image </td></tr>
    <tr><td class="paramname">sourceHeight</td><td>the height of the rectangle to copy from the source image </td></tr>
    <tr><td class="paramname">fillAlphaChannelWithCurrentBrush</td><td>if true, then instead of drawing the source image's pixels, the source image's alpha channel is used as a mask with which to fill the destination using the current colour or brush. (If the source is has no alpha channel, then it will just fill the target with a solid rectangle) </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classGraphics.html#a0f8160f9b0a6866e40cf1a2b45c3b892" title="Changes the quality that will be used when resampling images.">setImageResamplingQuality</a>, <a class="el" href="classGraphics.html#ab754b6a67c6964be2d27b1ba82bdae56" title="Draws an image.">drawImageAt</a>, <a class="el" href="classGraphics.html#a980e4beef03333ee1ec1ca7b7963ad63" title="Draws an image to fit within a designated rectangle.">drawImageWithin</a>, fillAlphaMap </dd></dl>

</div>
</div>
<a class="anchor" id="a79c4f544cd7fcada2be7d24691e157a3"></a><!-- doxytag: member="Graphics::drawImageTransformed" ref="a79c4f544cd7fcada2be7d24691e157a3" args="(const Image &amp;imageToDraw, const AffineTransform &amp;transform, bool fillAlphaChannelWithCurrentBrush=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a79c4f544cd7fcada2be7d24691e157a3">Graphics::drawImageTransformed</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classImage.html">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>imageToDraw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineTransform.html">AffineTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fillAlphaChannelWithCurrentBrush</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws an image, having applied an affine transform to it. </p>
<p>This lets you throw the image around in some wacky ways, rotate it, shear, scale it, etc.</p>
<p>Images are composited using the context's current opacity, so if you don't want it to be drawn semi-transparently, be sure to call setOpacity (1.0f) (or <a class="el" href="classGraphics.html#af17c43bb97e6822aa4b7b8a8adc40b99" title="Changes the current drawing colour.">setColour()</a> with an opaque colour) before drawing images.</p>
<p>If fillAlphaChannelWithCurrentBrush is set to true, then the image's RGB channels are ignored and it is filled with the current brush, masked by its alpha channel.</p>
<p>If you want to render only a subsection of an image, use <a class="el" href="classImage.html#a23f8ff9b07d67f2c60776d4031c27417" title="Returns an image which refers to a subsection of this image.">Image::getClippedImage()</a> to create the section that you need.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classGraphics.html#a0f8160f9b0a6866e40cf1a2b45c3b892" title="Changes the quality that will be used when resampling images.">setImageResamplingQuality</a>, <a class="el" href="classGraphics.html#a6e09218805a3eb3f7d4973433647d0e9" title="Draws part of an image, rescaling it to fit in a given target region.">drawImage</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a980e4beef03333ee1ec1ca7b7963ad63"></a><!-- doxytag: member="Graphics::drawImageWithin" ref="a980e4beef03333ee1ec1ca7b7963ad63" args="(const Image &amp;imageToDraw, int destX, int destY, int destWidth, int destHeight, const RectanglePlacement &amp;placementWithinTarget, bool fillAlphaChannelWithCurrentBrush=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a980e4beef03333ee1ec1ca7b7963ad63">Graphics::drawImageWithin</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classImage.html">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>imageToDraw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRectanglePlacement.html">RectanglePlacement</a> &amp;&#160;</td>
          <td class="paramname"><em>placementWithinTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fillAlphaChannelWithCurrentBrush</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws an image to fit within a designated rectangle. </p>
<p>If the image is too big or too small for the space, it will be rescaled to fit as nicely as it can do without affecting its aspect ratio. It will then be placed within the target rectangle according to the justification flags specified.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">imageToDraw</td><td>the source image to draw </td></tr>
    <tr><td class="paramname">destX</td><td>top-left of the target rectangle to fit it into </td></tr>
    <tr><td class="paramname">destY</td><td>top-left of the target rectangle to fit it into </td></tr>
    <tr><td class="paramname">destWidth</td><td>size of the target rectangle to fit the image into </td></tr>
    <tr><td class="paramname">destHeight</td><td>size of the target rectangle to fit the image into </td></tr>
    <tr><td class="paramname">placementWithinTarget</td><td>this specifies how the image should be positioned within the target rectangle - see the <a class="el" href="classRectanglePlacement.html" title="Defines the method used to postion some kind of rectangular object within a rectangular viewport...">RectanglePlacement</a> class for more details about this. </td></tr>
    <tr><td class="paramname">fillAlphaChannelWithCurrentBrush</td><td>if true, then instead of drawing the image, just its alpha channel will be used as a mask with which to draw with the current brush or colour. This is similar to fillAlphaMap(), and see also <a class="el" href="classGraphics.html#a6e09218805a3eb3f7d4973433647d0e9" title="Draws part of an image, rescaling it to fit in a given target region.">drawImage()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classGraphics.html#a0f8160f9b0a6866e40cf1a2b45c3b892" title="Changes the quality that will be used when resampling images.">setImageResamplingQuality</a>, <a class="el" href="classGraphics.html#a6e09218805a3eb3f7d4973433647d0e9" title="Draws part of an image, rescaling it to fit in a given target region.">drawImage</a>, <a class="el" href="classGraphics.html#a79c4f544cd7fcada2be7d24691e157a3" title="Draws an image, having applied an affine transform to it.">drawImageTransformed</a>, <a class="el" href="classGraphics.html#ab754b6a67c6964be2d27b1ba82bdae56" title="Draws an image.">drawImageAt</a>, <a class="el" href="classRectanglePlacement.html" title="Defines the method used to postion some kind of rectangular object within a rectangular viewport...">RectanglePlacement</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a34942cbdbd743d7fd332c218ea7e4c5d"></a><!-- doxytag: member="Graphics::getClipBounds" ref="a34942cbdbd743d7fd332c218ea7e4c5d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRectangle.html">Rectangle</a>&lt;int&gt; <a class="el" href="classGraphics.html#a34942cbdbd743d7fd332c218ea7e4c5d">Graphics::getClipBounds</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the position of the bounding box for the current clipping region. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>getClipRegion, <a class="el" href="classGraphics.html#a0a91a1c322713e070d8fd42796854340" title="Checks whether a rectangle overlaps the context&#39;s clipping region.">clipRegionIntersects</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0a91a1c322713e070d8fd42796854340"></a><!-- doxytag: member="Graphics::clipRegionIntersects" ref="a0a91a1c322713e070d8fd42796854340" args="(const Rectangle&lt; int &gt; &amp;area) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGraphics.html#a0a91a1c322713e070d8fd42796854340">Graphics::clipRegionIntersects</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRectangle.html">Rectangle</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>area</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks whether a rectangle overlaps the context's clipping region. </p>
<p>If this returns false, no part of the given area can be drawn onto, so this method can be used to optimise a component's paint() method, by letting it avoid drawing complex objects that aren't within the region being repainted. </p>

</div>
</div>
<a class="anchor" id="ad97e058fcff2bc0e634eacc4ef1d7a5f"></a><!-- doxytag: member="Graphics::reduceClipRegion" ref="ad97e058fcff2bc0e634eacc4ef1d7a5f" args="(int x, int y, int width, int height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGraphics.html#ad97e058fcff2bc0e634eacc4ef1d7a5f">Graphics::reduceClipRegion</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Intersects the current clipping region with another region. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the resulting clipping region is non-zero in size </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classGraphics.html#a9f6c05af33aefe49851d0d1eb9294bea" title="Moves the position of the context&#39;s origin.">setOrigin</a>, <a class="el" href="classGraphics.html#a0a91a1c322713e070d8fd42796854340" title="Checks whether a rectangle overlaps the context&#39;s clipping region.">clipRegionIntersects</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a97cba43cb492f57590b5f211e590e38f"></a><!-- doxytag: member="Graphics::reduceClipRegion" ref="a97cba43cb492f57590b5f211e590e38f" args="(const Rectangle&lt; int &gt; &amp;area)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGraphics.html#ad97e058fcff2bc0e634eacc4ef1d7a5f">Graphics::reduceClipRegion</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRectangle.html">Rectangle</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>area</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Intersects the current clipping region with another region. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the resulting clipping region is non-zero in size </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classGraphics.html#a9f6c05af33aefe49851d0d1eb9294bea" title="Moves the position of the context&#39;s origin.">setOrigin</a>, <a class="el" href="classGraphics.html#a0a91a1c322713e070d8fd42796854340" title="Checks whether a rectangle overlaps the context&#39;s clipping region.">clipRegionIntersects</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae30c76ed849ef8a987cb98191e0668e1"></a><!-- doxytag: member="Graphics::reduceClipRegion" ref="ae30c76ed849ef8a987cb98191e0668e1" args="(const RectangleList &amp;clipRegion)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGraphics.html#ad97e058fcff2bc0e634eacc4ef1d7a5f">Graphics::reduceClipRegion</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRectangleList.html">RectangleList</a> &amp;&#160;</td>
          <td class="paramname"><em>clipRegion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Intersects the current clipping region with a rectangle list region. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the resulting clipping region is non-zero in size </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classGraphics.html#a9f6c05af33aefe49851d0d1eb9294bea" title="Moves the position of the context&#39;s origin.">setOrigin</a>, <a class="el" href="classGraphics.html#a0a91a1c322713e070d8fd42796854340" title="Checks whether a rectangle overlaps the context&#39;s clipping region.">clipRegionIntersects</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a01d830805b335f8cdf52fadd00bd0d30"></a><!-- doxytag: member="Graphics::reduceClipRegion" ref="a01d830805b335f8cdf52fadd00bd0d30" args="(const Path &amp;path, const AffineTransform &amp;transform=AffineTransform::identity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGraphics.html#ad97e058fcff2bc0e634eacc4ef1d7a5f">Graphics::reduceClipRegion</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPath.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineTransform.html">AffineTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em> = <code><a class="el" href="classAffineTransform.html#a2173017e6300f667a23467505ca36276">AffineTransform::identity</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Intersects the current clipping region with a path. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the resulting clipping region is non-zero in size </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classGraphics.html#ad97e058fcff2bc0e634eacc4ef1d7a5f" title="Intersects the current clipping region with another region.">reduceClipRegion</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a735b5096ea063020134fdf1c570dec9a"></a><!-- doxytag: member="Graphics::reduceClipRegion" ref="a735b5096ea063020134fdf1c570dec9a" args="(const Image &amp;image, const AffineTransform &amp;transform)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGraphics.html#ad97e058fcff2bc0e634eacc4ef1d7a5f">Graphics::reduceClipRegion</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classImage.html">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineTransform.html">AffineTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Intersects the current clipping region with an image's alpha-channel. </p>
<p>The current clipping path is intersected with the area covered by this image's alpha-channel, after the image has been transformed by the specified matrix.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>the image whose alpha-channel should be used. If the image doesn't have an alpha-channel, it is treated as entirely opaque. </td></tr>
    <tr><td class="paramname">transform</td><td>a matrix to apply to the image </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the resulting clipping region is non-zero in size </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classGraphics.html#ad97e058fcff2bc0e634eacc4ef1d7a5f" title="Intersects the current clipping region with another region.">reduceClipRegion</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9ff97378305763a38f4a99bc638a8824"></a><!-- doxytag: member="Graphics::excludeClipRegion" ref="a9ff97378305763a38f4a99bc638a8824" args="(const Rectangle&lt; int &gt; &amp;rectangleToExclude)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a9ff97378305763a38f4a99bc638a8824">Graphics::excludeClipRegion</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRectangle.html">Rectangle</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>rectangleToExclude</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Excludes a rectangle to stop it being drawn into. </p>

</div>
</div>
<a class="anchor" id="a6ae806601e19bc1631085d6e2a7f5d74"></a><!-- doxytag: member="Graphics::isClipEmpty" ref="a6ae806601e19bc1631085d6e2a7f5d74" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGraphics.html#a6ae806601e19bc1631085d6e2a7f5d74">Graphics::isClipEmpty</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if no drawing can be done because the clip region is zero. </p>

</div>
</div>
<a class="anchor" id="ab4df35938684890f7adac0439e900ca8"></a><!-- doxytag: member="Graphics::saveState" ref="ab4df35938684890f7adac0439e900ca8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#ab4df35938684890f7adac0439e900ca8">Graphics::saveState</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Saves the current graphics state on an internal stack. </p>
<p>To restore the state, use <a class="el" href="classGraphics.html#ac724e99c9a7bcd8b2987a484e269a368" title="Restores a graphics state that was previously saved with saveState().">restoreState()</a>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classGraphics_1_1ScopedSaveState.html" title="Uses RAII to save and restore the state of a graphics context.">ScopedSaveState</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac724e99c9a7bcd8b2987a484e269a368"></a><!-- doxytag: member="Graphics::restoreState" ref="ac724e99c9a7bcd8b2987a484e269a368" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#ac724e99c9a7bcd8b2987a484e269a368">Graphics::restoreState</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Restores a graphics state that was previously saved with <a class="el" href="classGraphics.html#ab4df35938684890f7adac0439e900ca8" title="Saves the current graphics state on an internal stack.">saveState()</a>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classGraphics_1_1ScopedSaveState.html" title="Uses RAII to save and restore the state of a graphics context.">ScopedSaveState</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab8d8ee1c6bb810074eff904fd3c21fc4"></a><!-- doxytag: member="Graphics::beginTransparencyLayer" ref="ab8d8ee1c6bb810074eff904fd3c21fc4" args="(float layerOpacity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#ab8d8ee1c6bb810074eff904fd3c21fc4">Graphics::beginTransparencyLayer</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>layerOpacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Begins rendering to an off-screen bitmap which will later be flattened onto the current context with the given opacity. </p>
<p>The context uses an internal stack of temporary image layers to do this. When you've finished drawing to the layer, call <a class="el" href="classGraphics.html#ae6b36ef8295dd83d33287a328e88ef9c" title="Completes a drawing operation to a temporary semi-transparent buffer.">endTransparencyLayer()</a> to complete the operation and composite the finished layer. Every call to <a class="el" href="classGraphics.html#ab8d8ee1c6bb810074eff904fd3c21fc4" title="Begins rendering to an off-screen bitmap which will later be flattened onto the current context with ...">beginTransparencyLayer()</a> MUST be matched by a corresponding call to <a class="el" href="classGraphics.html#ae6b36ef8295dd83d33287a328e88ef9c" title="Completes a drawing operation to a temporary semi-transparent buffer.">endTransparencyLayer()</a>!</p>
<p>This call also saves the current state, and <a class="el" href="classGraphics.html#ae6b36ef8295dd83d33287a328e88ef9c" title="Completes a drawing operation to a temporary semi-transparent buffer.">endTransparencyLayer()</a> restores it. </p>

</div>
</div>
<a class="anchor" id="ae6b36ef8295dd83d33287a328e88ef9c"></a><!-- doxytag: member="Graphics::endTransparencyLayer" ref="ae6b36ef8295dd83d33287a328e88ef9c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#ae6b36ef8295dd83d33287a328e88ef9c">Graphics::endTransparencyLayer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Completes a drawing operation to a temporary semi-transparent buffer. </p>
<p>See <a class="el" href="classGraphics.html#ab8d8ee1c6bb810074eff904fd3c21fc4" title="Begins rendering to an off-screen bitmap which will later be flattened onto the current context with ...">beginTransparencyLayer()</a> for more details. </p>

</div>
</div>
<a class="anchor" id="a9f6c05af33aefe49851d0d1eb9294bea"></a><!-- doxytag: member="Graphics::setOrigin" ref="a9f6c05af33aefe49851d0d1eb9294bea" args="(int newOriginX, int newOriginY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a9f6c05af33aefe49851d0d1eb9294bea">Graphics::setOrigin</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newOriginX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newOriginY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves the position of the context's origin. </p>
<p>This changes the position that the context considers to be (0, 0) to the specified position.</p>
<p>So if you call setOrigin (100, 100), then the position that was previously referred to as (100, 100) will subsequently be considered to be (0, 0).</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classGraphics.html#ad97e058fcff2bc0e634eacc4ef1d7a5f" title="Intersects the current clipping region with another region.">reduceClipRegion</a>, <a class="el" href="classGraphics.html#a7d9d400fdb96d3c6bbb640fb94b54d06" title="Adds a transformation which will be performed on all the graphics operations that the context subsequ...">addTransform</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7d9d400fdb96d3c6bbb640fb94b54d06"></a><!-- doxytag: member="Graphics::addTransform" ref="a7d9d400fdb96d3c6bbb640fb94b54d06" args="(const AffineTransform &amp;transform)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a7d9d400fdb96d3c6bbb640fb94b54d06">Graphics::addTransform</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineTransform.html">AffineTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a transformation which will be performed on all the graphics operations that the context subsequently performs. </p>
<p>After calling this, all the coordinates that are passed into the context will be transformed by this matrix.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classGraphics.html#a9f6c05af33aefe49851d0d1eb9294bea" title="Moves the position of the context&#39;s origin.">setOrigin</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab8b7cd49bf1ff738c5ff848727e3bc75"></a><!-- doxytag: member="Graphics::resetToDefaultState" ref="ab8b7cd49bf1ff738c5ff848727e3bc75" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#ab8b7cd49bf1ff738c5ff848727e3bc75">Graphics::resetToDefaultState</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets the current colour, brush, and font to default settings. </p>

</div>
</div>
<a class="anchor" id="ae584e8878455891d9010addb384425cd"></a><!-- doxytag: member="Graphics::isVectorDevice" ref="ae584e8878455891d9010addb384425cd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGraphics.html#ae584e8878455891d9010addb384425cd">Graphics::isVectorDevice</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if this context is drawing to a vector-based device, such as a printer. </p>

</div>
</div>
<a class="anchor" id="a56d2788fe6978ee9da3b58864767e74a"></a><!-- doxytag: member="Graphics::getInternalContext" ref="a56d2788fe6978ee9da3b58864767e74a" args="() const noexcept" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLowLevelGraphicsContext.html">LowLevelGraphicsContext</a>* <a class="el" href="classGraphics.html#a56d2788fe6978ee9da3b58864767e74a">Graphics::getInternalContext</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="juce__GraphicsContext_8h.html">juce_GraphicsContext.h</a></li>
</ul>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/>
<address class="footer"><small>All content &copy Raw Material Software Ltd.</small></address><br/>
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-19759318-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
</html>
