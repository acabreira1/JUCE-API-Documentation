<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>JUCE: Graphics Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">JUCE
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Graphics Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A graphics context, used for drawing a component or image.  
 <a href="classGraphics.html#details">More...</a></p>

<p><a href="classGraphics-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics_1_1ScopedSaveState.html">ScopedSaveState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses RAII to save and restore the state of a graphics context.  <a href="classGraphics_1_1ScopedSaveState.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5da218e649d1b5ac3d67443ae77caf87"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a5da218e649d1b5ac3d67443ae77caf87">ResamplingQuality</a> { <a class="el" href="classGraphics.html#a5da218e649d1b5ac3d67443ae77caf87a4eb9cfa2e544befd2d50708e3316b28e">lowResamplingQuality</a> =  0, 
<a class="el" href="classGraphics.html#a5da218e649d1b5ac3d67443ae77caf87a5d8dfbf84457e91eb309b1402562f2af">mediumResamplingQuality</a> =  1, 
<a class="el" href="classGraphics.html#a5da218e649d1b5ac3d67443ae77caf87ae3c4b3cdf28f0aefc035977522675e8e">highResamplingQuality</a> =  2
 }</td></tr>
<tr class="memdesc:a5da218e649d1b5ac3d67443ae77caf87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of rendering quality that can be specified when drawing images.  <a href="classGraphics.html#a5da218e649d1b5ac3d67443ae77caf87">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ada6375a2e6bf68758a2191acb4d62c65"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ada6375a2e6bf68758a2191acb4d62c65">Graphics</a> (const <a class="el" href="classImage.html">Image</a> &amp;imageToDrawOnto)</td></tr>
<tr class="memdesc:ada6375a2e6bf68758a2191acb4d62c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classGraphics.html" title="A graphics context, used for drawing a component or image.">Graphics</a> object to draw directly onto the given image.  <a href="#ada6375a2e6bf68758a2191acb4d62c65"></a><br/></td></tr>
<tr class="memitem:a7841c9a961ac9bca33bd30ddf8066cdb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a7841c9a961ac9bca33bd30ddf8066cdb">~Graphics</a> ()</td></tr>
<tr class="memdesc:a7841c9a961ac9bca33bd30ddf8066cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a7841c9a961ac9bca33bd30ddf8066cdb"></a><br/></td></tr>
<tr class="memitem:af17c43bb97e6822aa4b7b8a8adc40b99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#af17c43bb97e6822aa4b7b8a8adc40b99">setColour</a> (const <a class="el" href="classColour.html">Colour</a> &amp;newColour)</td></tr>
<tr class="memdesc:af17c43bb97e6822aa4b7b8a8adc40b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the current drawing colour.  <a href="#af17c43bb97e6822aa4b7b8a8adc40b99"></a><br/></td></tr>
<tr class="memitem:a1ce91a31ec1258a73ace93b6c337dbb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a1ce91a31ec1258a73ace93b6c337dbb2">setOpacity</a> (float newOpacity)</td></tr>
<tr class="memdesc:a1ce91a31ec1258a73ace93b6c337dbb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the opacity to use with the current colour.  <a href="#a1ce91a31ec1258a73ace93b6c337dbb2"></a><br/></td></tr>
<tr class="memitem:a57478bc2496ebb84696e5ba64b455965"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a57478bc2496ebb84696e5ba64b455965">setGradientFill</a> (const <a class="el" href="classColourGradient.html">ColourGradient</a> &amp;gradient)</td></tr>
<tr class="memdesc:a57478bc2496ebb84696e5ba64b455965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the context to use a gradient for its fill pattern.  <a href="#a57478bc2496ebb84696e5ba64b455965"></a><br/></td></tr>
<tr class="memitem:a675cd4c4715165f0a0aec0bd8c3fe390"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a675cd4c4715165f0a0aec0bd8c3fe390">setTiledImageFill</a> (const <a class="el" href="classImage.html">Image</a> &amp;imageToUse, int anchorX, int anchorY, float opacity)</td></tr>
<tr class="memdesc:a675cd4c4715165f0a0aec0bd8c3fe390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the context to use a tiled image pattern for filling.  <a href="#a675cd4c4715165f0a0aec0bd8c3fe390"></a><br/></td></tr>
<tr class="memitem:a763ea233d7b7c8e45e33c7ea8030ff48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a763ea233d7b7c8e45e33c7ea8030ff48">setFillType</a> (const <a class="el" href="classFillType.html">FillType</a> &amp;newFill)</td></tr>
<tr class="memdesc:a763ea233d7b7c8e45e33c7ea8030ff48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the current fill settings.  <a href="#a763ea233d7b7c8e45e33c7ea8030ff48"></a><br/></td></tr>
<tr class="memitem:a1fbdb321975d90c45243027a61ac2be9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a1fbdb321975d90c45243027a61ac2be9">setFont</a> (const <a class="el" href="classFont.html">Font</a> &amp;newFont)</td></tr>
<tr class="memdesc:a1fbdb321975d90c45243027a61ac2be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the font to use for subsequent text-drawing functions.  <a href="#a1fbdb321975d90c45243027a61ac2be9"></a><br/></td></tr>
<tr class="memitem:a8c9a73240eab843cbf93393956910e72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a8c9a73240eab843cbf93393956910e72">setFont</a> (float newFontHeight)</td></tr>
<tr class="memdesc:a8c9a73240eab843cbf93393956910e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the size of the currently-selected font.  <a href="#a8c9a73240eab843cbf93393956910e72"></a><br/></td></tr>
<tr class="memitem:abb972f0d801630b6e02d335cfa9da28a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFont.html">Font</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#abb972f0d801630b6e02d335cfa9da28a">getCurrentFont</a> () const </td></tr>
<tr class="memdesc:abb972f0d801630b6e02d335cfa9da28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the currently selected font.  <a href="#abb972f0d801630b6e02d335cfa9da28a"></a><br/></td></tr>
<tr class="memitem:ade61955c11b56c91232b350dbfbf1b81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ade61955c11b56c91232b350dbfbf1b81">drawSingleLineText</a> (const <a class="el" href="classString.html">String</a> &amp;text, int startX, int baselineY, const <a class="el" href="classJustification.html">Justification</a> &amp;justification=<a class="el" href="classJustification.html#a2e0d86f7f4f1a05b0581af05d70e84bda56156bb2892e32febf8011af9c5da653">Justification::left</a>) const </td></tr>
<tr class="memdesc:ade61955c11b56c91232b350dbfbf1b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a one-line text string.  <a href="#ade61955c11b56c91232b350dbfbf1b81"></a><br/></td></tr>
<tr class="memitem:a37c017a9d2f32bcd677f61f5de97ab9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a37c017a9d2f32bcd677f61f5de97ab9a">drawMultiLineText</a> (const <a class="el" href="classString.html">String</a> &amp;text, int startX, int baselineY, int maximumLineWidth) const </td></tr>
<tr class="memdesc:a37c017a9d2f32bcd677f61f5de97ab9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws text across multiple lines.  <a href="#a37c017a9d2f32bcd677f61f5de97ab9a"></a><br/></td></tr>
<tr class="memitem:a837821b4bab764d76df560350e069b45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a837821b4bab764d76df560350e069b45">drawTextAsPath</a> (const <a class="el" href="classString.html">String</a> &amp;text, const <a class="el" href="classAffineTransform.html">AffineTransform</a> &amp;transform) const </td></tr>
<tr class="memdesc:a837821b4bab764d76df560350e069b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a string of text as a vector path.  <a href="#a837821b4bab764d76df560350e069b45"></a><br/></td></tr>
<tr class="memitem:aa03c871748cf584b548663b79da7926c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#aa03c871748cf584b548663b79da7926c">drawText</a> (const <a class="el" href="classString.html">String</a> &amp;text, int x, int y, int width, int height, const <a class="el" href="classJustification.html">Justification</a> &amp;justificationType, bool useEllipsesIfTooBig) const </td></tr>
<tr class="memdesc:aa03c871748cf584b548663b79da7926c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a line of text within a specified rectangle.  <a href="#aa03c871748cf584b548663b79da7926c"></a><br/></td></tr>
<tr class="memitem:a84311fce34d51ada6738d3118f38a0b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a84311fce34d51ada6738d3118f38a0b1">drawText</a> (const <a class="el" href="classString.html">String</a> &amp;text, const <a class="el" href="classRectangle.html">Rectangle</a>&lt; int &gt; &amp;area, const <a class="el" href="classJustification.html">Justification</a> &amp;justificationType, bool useEllipsesIfTooBig) const </td></tr>
<tr class="memdesc:a84311fce34d51ada6738d3118f38a0b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a line of text within a specified rectangle.  <a href="#a84311fce34d51ada6738d3118f38a0b1"></a><br/></td></tr>
<tr class="memitem:ad2c56e11c42bc7404233b9a23e939ede"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ad2c56e11c42bc7404233b9a23e939ede">drawFittedText</a> (const <a class="el" href="classString.html">String</a> &amp;text, int x, int y, int width, int height, const <a class="el" href="classJustification.html">Justification</a> &amp;justificationFlags, int maximumNumberOfLines, float minimumHorizontalScale=0.7f) const </td></tr>
<tr class="memdesc:ad2c56e11c42bc7404233b9a23e939ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to draw a text string inside a given space.  <a href="#ad2c56e11c42bc7404233b9a23e939ede"></a><br/></td></tr>
<tr class="memitem:a278d7ad0e7697198003e2393d2331eb6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a278d7ad0e7697198003e2393d2331eb6">drawFittedText</a> (const <a class="el" href="classString.html">String</a> &amp;text, const <a class="el" href="classRectangle.html">Rectangle</a>&lt; int &gt; &amp;area, const <a class="el" href="classJustification.html">Justification</a> &amp;justificationFlags, int maximumNumberOfLines, float minimumHorizontalScale=0.7f) const </td></tr>
<tr class="memdesc:a278d7ad0e7697198003e2393d2331eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to draw a text string inside a given space.  <a href="#a278d7ad0e7697198003e2393d2331eb6"></a><br/></td></tr>
<tr class="memitem:a516a7795e6e0c6c70eb982a83ea0b8c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a516a7795e6e0c6c70eb982a83ea0b8c3">fillAll</a> () const </td></tr>
<tr class="memdesc:a516a7795e6e0c6c70eb982a83ea0b8c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the context's entire clip region with the current colour or brush.  <a href="#a516a7795e6e0c6c70eb982a83ea0b8c3"></a><br/></td></tr>
<tr class="memitem:a29e9bc174cf54be0f423172e24d5cf78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a29e9bc174cf54be0f423172e24d5cf78">fillAll</a> (const <a class="el" href="classColour.html">Colour</a> &amp;colourToUse) const </td></tr>
<tr class="memdesc:a29e9bc174cf54be0f423172e24d5cf78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the context's entire clip region with a given colour.  <a href="#a29e9bc174cf54be0f423172e24d5cf78"></a><br/></td></tr>
<tr class="memitem:ac2202ef993b53d77d8646ed4ce3ea9d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ac2202ef993b53d77d8646ed4ce3ea9d1">fillRect</a> (int x, int y, int width, int height) const </td></tr>
<tr class="memdesc:ac2202ef993b53d77d8646ed4ce3ea9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a rectangle with the current colour or brush.  <a href="#ac2202ef993b53d77d8646ed4ce3ea9d1"></a><br/></td></tr>
<tr class="memitem:a9ff78524c757a302ad8b9cbc4c7ba851"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a9ff78524c757a302ad8b9cbc4c7ba851">fillRect</a> (const <a class="el" href="classRectangle.html">Rectangle</a>&lt; int &gt; &amp;rectangle) const </td></tr>
<tr class="memdesc:a9ff78524c757a302ad8b9cbc4c7ba851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a rectangle with the current colour or brush.  <a href="#a9ff78524c757a302ad8b9cbc4c7ba851"></a><br/></td></tr>
<tr class="memitem:a018bffc13a318cb5e59d29b258313b8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a018bffc13a318cb5e59d29b258313b8b">fillRect</a> (float x, float y, float width, float height) const </td></tr>
<tr class="memdesc:a018bffc13a318cb5e59d29b258313b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a rectangle with the current colour or brush.  <a href="#a018bffc13a318cb5e59d29b258313b8b"></a><br/></td></tr>
<tr class="memitem:a1049a2dae8a1ae3e5e57238f2fd36a84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a1049a2dae8a1ae3e5e57238f2fd36a84">fillRoundedRectangle</a> (float x, float y, float width, float height, float cornerSize) const </td></tr>
<tr class="memdesc:a1049a2dae8a1ae3e5e57238f2fd36a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the current colour or brush to fill a rectangle with rounded corners.  <a href="#a1049a2dae8a1ae3e5e57238f2fd36a84"></a><br/></td></tr>
<tr class="memitem:afc06f32c228086e55876184176314bd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#afc06f32c228086e55876184176314bd1">fillRoundedRectangle</a> (const <a class="el" href="classRectangle.html">Rectangle</a>&lt; float &gt; &amp;rectangle, float cornerSize) const </td></tr>
<tr class="memdesc:afc06f32c228086e55876184176314bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the current colour or brush to fill a rectangle with rounded corners.  <a href="#afc06f32c228086e55876184176314bd1"></a><br/></td></tr>
<tr class="memitem:a359717e34bed0f5dfd2f3004b3cea19f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a359717e34bed0f5dfd2f3004b3cea19f">fillCheckerBoard</a> (const <a class="el" href="classRectangle.html">Rectangle</a>&lt; int &gt; &amp;area, int checkWidth, int checkHeight, const <a class="el" href="classColour.html">Colour</a> &amp;colour1, const <a class="el" href="classColour.html">Colour</a> &amp;colour2) const </td></tr>
<tr class="memdesc:a359717e34bed0f5dfd2f3004b3cea19f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a rectangle with a checkerboard pattern, alternating between two colours.  <a href="#a359717e34bed0f5dfd2f3004b3cea19f"></a><br/></td></tr>
<tr class="memitem:a28baf90f8e11ec6f96c349f45e09a9d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a28baf90f8e11ec6f96c349f45e09a9d0">drawRect</a> (int x, int y, int width, int height, int lineThickness=1) const </td></tr>
<tr class="memdesc:a28baf90f8e11ec6f96c349f45e09a9d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws four lines to form a rectangular outline, using the current colour or brush.  <a href="#a28baf90f8e11ec6f96c349f45e09a9d0"></a><br/></td></tr>
<tr class="memitem:a7b8a15c73c5d797cd169852224236f4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a7b8a15c73c5d797cd169852224236f4f">drawRect</a> (float x, float y, float width, float height, float lineThickness=1.0f) const </td></tr>
<tr class="memdesc:a7b8a15c73c5d797cd169852224236f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws four lines to form a rectangular outline, using the current colour or brush.  <a href="#a7b8a15c73c5d797cd169852224236f4f"></a><br/></td></tr>
<tr class="memitem:a88e7c28b48c3f2e9e2c9df7d2571908f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a88e7c28b48c3f2e9e2c9df7d2571908f">drawRect</a> (const <a class="el" href="classRectangle.html">Rectangle</a>&lt; int &gt; &amp;rectangle, int lineThickness=1) const </td></tr>
<tr class="memdesc:a88e7c28b48c3f2e9e2c9df7d2571908f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws four lines to form a rectangular outline, using the current colour or brush.  <a href="#a88e7c28b48c3f2e9e2c9df7d2571908f"></a><br/></td></tr>
<tr class="memitem:a78541e36136eb040c4b8c81d4b8db8dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a78541e36136eb040c4b8c81d4b8db8dd">drawRoundedRectangle</a> (float x, float y, float width, float height, float cornerSize, float lineThickness) const </td></tr>
<tr class="memdesc:a78541e36136eb040c4b8c81d4b8db8dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the current colour or brush to draw the outline of a rectangle with rounded corners.  <a href="#a78541e36136eb040c4b8c81d4b8db8dd"></a><br/></td></tr>
<tr class="memitem:a91706e86b7120523346fee8f2161d48f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a91706e86b7120523346fee8f2161d48f">drawRoundedRectangle</a> (const <a class="el" href="classRectangle.html">Rectangle</a>&lt; float &gt; &amp;rectangle, float cornerSize, float lineThickness) const </td></tr>
<tr class="memdesc:a91706e86b7120523346fee8f2161d48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the current colour or brush to draw the outline of a rectangle with rounded corners.  <a href="#a91706e86b7120523346fee8f2161d48f"></a><br/></td></tr>
<tr class="memitem:a69e70db1afc03d58f9055f8f45d8e5d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a69e70db1afc03d58f9055f8f45d8e5d1">setPixel</a> (int x, int y) const </td></tr>
<tr class="memdesc:a69e70db1afc03d58f9055f8f45d8e5d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a 1x1 pixel using the current colour or brush.  <a href="#a69e70db1afc03d58f9055f8f45d8e5d1"></a><br/></td></tr>
<tr class="memitem:ab6fdfd1cb32b32d52b6b30df36321f70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ab6fdfd1cb32b32d52b6b30df36321f70">fillEllipse</a> (float x, float y, float width, float height) const </td></tr>
<tr class="memdesc:ab6fdfd1cb32b32d52b6b30df36321f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills an ellipse with the current colour or brush.  <a href="#ab6fdfd1cb32b32d52b6b30df36321f70"></a><br/></td></tr>
<tr class="memitem:a4f58ce68f75ec835a4863e756ec11bed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a4f58ce68f75ec835a4863e756ec11bed">fillEllipse</a> (const <a class="el" href="classRectangle.html">Rectangle</a>&lt; float &gt; &amp;area) const </td></tr>
<tr class="memdesc:a4f58ce68f75ec835a4863e756ec11bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills an ellipse with the current colour or brush.  <a href="#a4f58ce68f75ec835a4863e756ec11bed"></a><br/></td></tr>
<tr class="memitem:ac88110d5407539aa1be841a89d5170b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ac88110d5407539aa1be841a89d5170b0">drawEllipse</a> (float x, float y, float width, float height, float lineThickness) const </td></tr>
<tr class="memdesc:ac88110d5407539aa1be841a89d5170b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws an elliptical stroke using the current colour or brush.  <a href="#ac88110d5407539aa1be841a89d5170b0"></a><br/></td></tr>
<tr class="memitem:a0911bf63fd6c0d3e35b2b701fcbc7728"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a0911bf63fd6c0d3e35b2b701fcbc7728">drawLine</a> (float startX, float startY, float endX, float endY) const </td></tr>
<tr class="memdesc:a0911bf63fd6c0d3e35b2b701fcbc7728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a line between two points.  <a href="#a0911bf63fd6c0d3e35b2b701fcbc7728"></a><br/></td></tr>
<tr class="memitem:a664643f9fef3c8b37b0620c28ec4bb76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a664643f9fef3c8b37b0620c28ec4bb76">drawLine</a> (float startX, float startY, float endX, float endY, float lineThickness) const </td></tr>
<tr class="memdesc:a664643f9fef3c8b37b0620c28ec4bb76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a line between two points with a given thickness.  <a href="#a664643f9fef3c8b37b0620c28ec4bb76"></a><br/></td></tr>
<tr class="memitem:a94cf6a3a058ad1a36dc836b34916ef0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a94cf6a3a058ad1a36dc836b34916ef0d">drawLine</a> (const <a class="el" href="classLine.html">Line</a>&lt; float &gt; &amp;line) const </td></tr>
<tr class="memdesc:a94cf6a3a058ad1a36dc836b34916ef0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a line between two points.  <a href="#a94cf6a3a058ad1a36dc836b34916ef0d"></a><br/></td></tr>
<tr class="memitem:ace7c180c66f119399acb69ad966057e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ace7c180c66f119399acb69ad966057e3">drawLine</a> (const <a class="el" href="classLine.html">Line</a>&lt; float &gt; &amp;line, float lineThickness) const </td></tr>
<tr class="memdesc:ace7c180c66f119399acb69ad966057e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a line between two points with a given thickness.  <a href="#ace7c180c66f119399acb69ad966057e3"></a><br/></td></tr>
<tr class="memitem:ab24a3f2ba3d648285fcad7c97fb8270f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ab24a3f2ba3d648285fcad7c97fb8270f">drawDashedLine</a> (const <a class="el" href="classLine.html">Line</a>&lt; float &gt; &amp;line, const float *dashLengths, int numDashLengths, float lineThickness=1.0f, int dashIndexToStartFrom=0) const </td></tr>
<tr class="memdesc:ab24a3f2ba3d648285fcad7c97fb8270f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a dashed line using a custom set of dash-lengths.  <a href="#ab24a3f2ba3d648285fcad7c97fb8270f"></a><br/></td></tr>
<tr class="memitem:a042d4f7223a63212ae1d9452e26cbd7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a042d4f7223a63212ae1d9452e26cbd7a">drawVerticalLine</a> (int x, float top, float bottom) const </td></tr>
<tr class="memdesc:a042d4f7223a63212ae1d9452e26cbd7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a vertical line of pixels at a given x position.  <a href="#a042d4f7223a63212ae1d9452e26cbd7a"></a><br/></td></tr>
<tr class="memitem:aeea9ba47ff90bb7643038692bf647738"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#aeea9ba47ff90bb7643038692bf647738">drawHorizontalLine</a> (int y, float left, float right) const </td></tr>
<tr class="memdesc:aeea9ba47ff90bb7643038692bf647738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a horizontal line of pixels at a given y position.  <a href="#aeea9ba47ff90bb7643038692bf647738"></a><br/></td></tr>
<tr class="memitem:a129aa4c9dcc137a1c910a2f5ef118fb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a129aa4c9dcc137a1c910a2f5ef118fb7">fillPath</a> (const <a class="el" href="classPath.html">Path</a> &amp;path, const <a class="el" href="classAffineTransform.html">AffineTransform</a> &amp;transform=<a class="el" href="classAffineTransform.html#a2173017e6300f667a23467505ca36276">AffineTransform::identity</a>) const </td></tr>
<tr class="memdesc:a129aa4c9dcc137a1c910a2f5ef118fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a path using the currently selected colour or brush.  <a href="#a129aa4c9dcc137a1c910a2f5ef118fb7"></a><br/></td></tr>
<tr class="memitem:a5bd626168d02b83d10123e398da5c5a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a5bd626168d02b83d10123e398da5c5a7">strokePath</a> (const <a class="el" href="classPath.html">Path</a> &amp;path, const <a class="el" href="classPathStrokeType.html">PathStrokeType</a> &amp;strokeType, const <a class="el" href="classAffineTransform.html">AffineTransform</a> &amp;transform=<a class="el" href="classAffineTransform.html#a2173017e6300f667a23467505ca36276">AffineTransform::identity</a>) const </td></tr>
<tr class="memdesc:a5bd626168d02b83d10123e398da5c5a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a path's outline using the currently selected colour or brush.  <a href="#a5bd626168d02b83d10123e398da5c5a7"></a><br/></td></tr>
<tr class="memitem:ab1484b102f99384c443cfb5881d68fa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ab1484b102f99384c443cfb5881d68fa9">drawArrow</a> (const <a class="el" href="classLine.html">Line</a>&lt; float &gt; &amp;line, float lineThickness, float arrowheadWidth, float arrowheadLength) const </td></tr>
<tr class="memdesc:ab1484b102f99384c443cfb5881d68fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a line with an arrowhead at its end.  <a href="#ab1484b102f99384c443cfb5881d68fa9"></a><br/></td></tr>
<tr class="memitem:a0f8160f9b0a6866e40cf1a2b45c3b892"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a0f8160f9b0a6866e40cf1a2b45c3b892">setImageResamplingQuality</a> (const <a class="el" href="classGraphics.html#a5da218e649d1b5ac3d67443ae77caf87">ResamplingQuality</a> newQuality)</td></tr>
<tr class="memdesc:a0f8160f9b0a6866e40cf1a2b45c3b892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the quality that will be used when resampling images.  <a href="#a0f8160f9b0a6866e40cf1a2b45c3b892"></a><br/></td></tr>
<tr class="memitem:ab754b6a67c6964be2d27b1ba82bdae56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ab754b6a67c6964be2d27b1ba82bdae56">drawImageAt</a> (const <a class="el" href="classImage.html">Image</a> &amp;imageToDraw, int topLeftX, int topLeftY, bool fillAlphaChannelWithCurrentBrush=false) const </td></tr>
<tr class="memdesc:ab754b6a67c6964be2d27b1ba82bdae56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws an image.  <a href="#ab754b6a67c6964be2d27b1ba82bdae56"></a><br/></td></tr>
<tr class="memitem:a6e09218805a3eb3f7d4973433647d0e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a6e09218805a3eb3f7d4973433647d0e9">drawImage</a> (const <a class="el" href="classImage.html">Image</a> &amp;imageToDraw, int destX, int destY, int destWidth, int destHeight, int sourceX, int sourceY, int sourceWidth, int sourceHeight, bool fillAlphaChannelWithCurrentBrush=false) const </td></tr>
<tr class="memdesc:a6e09218805a3eb3f7d4973433647d0e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws part of an image, rescaling it to fit in a given target region.  <a href="#a6e09218805a3eb3f7d4973433647d0e9"></a><br/></td></tr>
<tr class="memitem:a79c4f544cd7fcada2be7d24691e157a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a79c4f544cd7fcada2be7d24691e157a3">drawImageTransformed</a> (const <a class="el" href="classImage.html">Image</a> &amp;imageToDraw, const <a class="el" href="classAffineTransform.html">AffineTransform</a> &amp;transform, bool fillAlphaChannelWithCurrentBrush=false) const </td></tr>
<tr class="memdesc:a79c4f544cd7fcada2be7d24691e157a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws an image, having applied an affine transform to it.  <a href="#a79c4f544cd7fcada2be7d24691e157a3"></a><br/></td></tr>
<tr class="memitem:a980e4beef03333ee1ec1ca7b7963ad63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a980e4beef03333ee1ec1ca7b7963ad63">drawImageWithin</a> (const <a class="el" href="classImage.html">Image</a> &amp;imageToDraw, int destX, int destY, int destWidth, int destHeight, const <a class="el" href="classRectanglePlacement.html">RectanglePlacement</a> &amp;placementWithinTarget, bool fillAlphaChannelWithCurrentBrush=false) const </td></tr>
<tr class="memdesc:a980e4beef03333ee1ec1ca7b7963ad63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws an image to fit within a designated rectangle.  <a href="#a980e4beef03333ee1ec1ca7b7963ad63"></a><br/></td></tr>
<tr class="memitem:a34942cbdbd743d7fd332c218ea7e4c5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRectangle.html">Rectangle</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a34942cbdbd743d7fd332c218ea7e4c5d">getClipBounds</a> () const </td></tr>
<tr class="memdesc:a34942cbdbd743d7fd332c218ea7e4c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the bounding box for the current clipping region.  <a href="#a34942cbdbd743d7fd332c218ea7e4c5d"></a><br/></td></tr>
<tr class="memitem:a0a91a1c322713e070d8fd42796854340"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a0a91a1c322713e070d8fd42796854340">clipRegionIntersects</a> (const <a class="el" href="classRectangle.html">Rectangle</a>&lt; int &gt; &amp;area) const </td></tr>
<tr class="memdesc:a0a91a1c322713e070d8fd42796854340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a rectangle overlaps the context's clipping region.  <a href="#a0a91a1c322713e070d8fd42796854340"></a><br/></td></tr>
<tr class="memitem:ad97e058fcff2bc0e634eacc4ef1d7a5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ad97e058fcff2bc0e634eacc4ef1d7a5f">reduceClipRegion</a> (int x, int y, int width, int height)</td></tr>
<tr class="memdesc:ad97e058fcff2bc0e634eacc4ef1d7a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects the current clipping region with another region.  <a href="#ad97e058fcff2bc0e634eacc4ef1d7a5f"></a><br/></td></tr>
<tr class="memitem:a97cba43cb492f57590b5f211e590e38f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a97cba43cb492f57590b5f211e590e38f">reduceClipRegion</a> (const <a class="el" href="classRectangle.html">Rectangle</a>&lt; int &gt; &amp;area)</td></tr>
<tr class="memdesc:a97cba43cb492f57590b5f211e590e38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects the current clipping region with another region.  <a href="#a97cba43cb492f57590b5f211e590e38f"></a><br/></td></tr>
<tr class="memitem:ae30c76ed849ef8a987cb98191e0668e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ae30c76ed849ef8a987cb98191e0668e1">reduceClipRegion</a> (const <a class="el" href="classRectangleList.html">RectangleList</a> &amp;clipRegion)</td></tr>
<tr class="memdesc:ae30c76ed849ef8a987cb98191e0668e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects the current clipping region with a rectangle list region.  <a href="#ae30c76ed849ef8a987cb98191e0668e1"></a><br/></td></tr>
<tr class="memitem:a01d830805b335f8cdf52fadd00bd0d30"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a01d830805b335f8cdf52fadd00bd0d30">reduceClipRegion</a> (const <a class="el" href="classPath.html">Path</a> &amp;path, const <a class="el" href="classAffineTransform.html">AffineTransform</a> &amp;transform=<a class="el" href="classAffineTransform.html#a2173017e6300f667a23467505ca36276">AffineTransform::identity</a>)</td></tr>
<tr class="memdesc:a01d830805b335f8cdf52fadd00bd0d30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects the current clipping region with a path.  <a href="#a01d830805b335f8cdf52fadd00bd0d30"></a><br/></td></tr>
<tr class="memitem:a735b5096ea063020134fdf1c570dec9a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a735b5096ea063020134fdf1c570dec9a">reduceClipRegion</a> (const <a class="el" href="classImage.html">Image</a> &amp;image, const <a class="el" href="classAffineTransform.html">AffineTransform</a> &amp;transform)</td></tr>
<tr class="memdesc:a735b5096ea063020134fdf1c570dec9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects the current clipping region with an image's alpha-channel.  <a href="#a735b5096ea063020134fdf1c570dec9a"></a><br/></td></tr>
<tr class="memitem:a9ff97378305763a38f4a99bc638a8824"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a9ff97378305763a38f4a99bc638a8824">excludeClipRegion</a> (const <a class="el" href="classRectangle.html">Rectangle</a>&lt; int &gt; &amp;rectangleToExclude)</td></tr>
<tr class="memdesc:a9ff97378305763a38f4a99bc638a8824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Excludes a rectangle to stop it being drawn into.  <a href="#a9ff97378305763a38f4a99bc638a8824"></a><br/></td></tr>
<tr class="memitem:a6ae806601e19bc1631085d6e2a7f5d74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a6ae806601e19bc1631085d6e2a7f5d74">isClipEmpty</a> () const </td></tr>
<tr class="memdesc:a6ae806601e19bc1631085d6e2a7f5d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if no drawing can be done because the clip region is zero.  <a href="#a6ae806601e19bc1631085d6e2a7f5d74"></a><br/></td></tr>
<tr class="memitem:ab4df35938684890f7adac0439e900ca8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ab4df35938684890f7adac0439e900ca8">saveState</a> ()</td></tr>
<tr class="memdesc:ab4df35938684890f7adac0439e900ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the current graphics state on an internal stack.  <a href="#ab4df35938684890f7adac0439e900ca8"></a><br/></td></tr>
<tr class="memitem:ac724e99c9a7bcd8b2987a484e269a368"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ac724e99c9a7bcd8b2987a484e269a368">restoreState</a> ()</td></tr>
<tr class="memdesc:ac724e99c9a7bcd8b2987a484e269a368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores a graphics state that was previously saved with <a class="el" href="classGraphics.html#ab4df35938684890f7adac0439e900ca8" title="Saves the current graphics state on an internal stack.">saveState()</a>.  <a href="#ac724e99c9a7bcd8b2987a484e269a368"></a><br/></td></tr>
<tr class="memitem:ab8d8ee1c6bb810074eff904fd3c21fc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ab8d8ee1c6bb810074eff904fd3c21fc4">beginTransparencyLayer</a> (float layerOpacity)</td></tr>
<tr class="memdesc:ab8d8ee1c6bb810074eff904fd3c21fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins rendering to an off-screen bitmap which will later be flattened onto the current context with the given opacity.  <a href="#ab8d8ee1c6bb810074eff904fd3c21fc4"></a><br/></td></tr>
<tr class="memitem:ae6b36ef8295dd83d33287a328e88ef9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ae6b36ef8295dd83d33287a328e88ef9c">endTransparencyLayer</a> ()</td></tr>
<tr class="memdesc:ae6b36ef8295dd83d33287a328e88ef9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completes a drawing operation to a temporary semi-transparent buffer.  <a href="#ae6b36ef8295dd83d33287a328e88ef9c"></a><br/></td></tr>
<tr class="memitem:a9f6c05af33aefe49851d0d1eb9294bea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a9f6c05af33aefe49851d0d1eb9294bea">setOrigin</a> (int newOriginX, int newOriginY)</td></tr>
<tr class="memdesc:a9f6c05af33aefe49851d0d1eb9294bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the position of the context's origin.  <a href="#a9f6c05af33aefe49851d0d1eb9294bea"></a><br/></td></tr>
<tr class="memitem:a7d9d400fdb96d3c6bbb640fb94b54d06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a7d9d400fdb96d3c6bbb640fb94b54d06">addTransform</a> (const <a class="el" href="classAffineTransform.html">AffineTransform</a> &amp;transform)</td></tr>
<tr class="memdesc:a7d9d400fdb96d3c6bbb640fb94b54d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a transformation which will be performed on all the graphics operations that the context subsequently performs.  <a href="#a7d9d400fdb96d3c6bbb640fb94b54d06"></a><br/></td></tr>
<tr class="memitem:ab8b7cd49bf1ff738c5ff848727e3bc75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ab8b7cd49bf1ff738c5ff848727e3bc75">resetToDefaultState</a> ()</td></tr>
<tr class="memdesc:ab8b7cd49bf1ff738c5ff848727e3bc75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the current colour, brush, and font to default settings.  <a href="#ab8b7cd49bf1ff738c5ff848727e3bc75"></a><br/></td></tr>
<tr class="memitem:ae584e8878455891d9010addb384425cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#ae584e8878455891d9010addb384425cd">isVectorDevice</a> () const </td></tr>
<tr class="memdesc:ae584e8878455891d9010addb384425cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this context is drawing to a vector-based device, such as a printer.  <a href="#ae584e8878455891d9010addb384425cd"></a><br/></td></tr>
<tr class="memitem:a1987cd53996367fd894885033ec39612"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a1987cd53996367fd894885033ec39612">Graphics</a> (<a class="el" href="classLowLevelGraphicsContext.html">LowLevelGraphicsContext</a> *) noexcept</td></tr>
<tr class="memdesc:a1987cd53996367fd894885033ec39612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a graphics that uses a given low-level renderer.  <a href="#a1987cd53996367fd894885033ec39612"></a><br/></td></tr>
<tr class="memitem:a504995c303f45cce740dda9fa67f1a64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLowLevelGraphicsContext.html">LowLevelGraphicsContext</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphics.html#a504995c303f45cce740dda9fa67f1a64">getInternalContext</a> () const noexcept</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A graphics context, used for drawing a component or image. </p>
<p>When a <a class="el" href="classComponent.html" title="The base class for all JUCE user-interface objects.">Component</a> needs painting, a <a class="el" href="classGraphics.html" title="A graphics context, used for drawing a component or image.">Graphics</a> context is passed to its <a class="el" href="classComponent.html#a7cf1862f4af5909ea72827898114a182" title="Components can override this method to draw their content.">Component::paint()</a> method, and this you then call methods within this object to actually draw the component's content.</p>
<p>A <a class="el" href="classGraphics.html" title="A graphics context, used for drawing a component or image.">Graphics</a> can also be created from an image, to allow drawing directly onto that image.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classComponent.html#a7cf1862f4af5909ea72827898114a182" title="Components can override this method to draw their content.">Component::paint</a> </dd></dl>
</div><hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a5da218e649d1b5ac3d67443ae77caf87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classGraphics.html#a5da218e649d1b5ac3d67443ae77caf87">Graphics::ResamplingQuality</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Types of rendering quality that can be specified when drawing images. </p>
<dl class="section see"><dt>See also:</dt><dd>blendImage, <a class="el" href="classGraphics.html#a0f8160f9b0a6866e40cf1a2b45c3b892" title="Changes the quality that will be used when resampling images.">Graphics::setImageResamplingQuality</a> </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a5da218e649d1b5ac3d67443ae77caf87a4eb9cfa2e544befd2d50708e3316b28e"></a>lowResamplingQuality</em>&nbsp;</td><td>
<p>Just uses a nearest-neighbour algorithm for resampling. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5da218e649d1b5ac3d67443ae77caf87a5d8dfbf84457e91eb309b1402562f2af"></a>mediumResamplingQuality</em>&nbsp;</td><td>
<p>Uses bilinear interpolation for upsampling and area-averaging for downsampling. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5da218e649d1b5ac3d67443ae77caf87ae3c4b3cdf28f0aefc035977522675e8e"></a>highResamplingQuality</em>&nbsp;</td><td>
<p>Uses bicubic interpolation for upsampling and area-averaging for downsampling. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ada6375a2e6bf68758a2191acb4d62c65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraphics.html#ada6375a2e6bf68758a2191acb4d62c65">Graphics::Graphics</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classImage.html">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>imageToDrawOnto</em></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a <a class="el" href="classGraphics.html" title="A graphics context, used for drawing a component or image.">Graphics</a> object to draw directly onto the given image. </p>
<p>The graphics object that is created will be set up to draw onto the image, with the context's clipping area being the entire size of the image, and its origin being the image's origin. To draw into a subsection of an image, use the <a class="el" href="classGraphics.html#ad97e058fcff2bc0e634eacc4ef1d7a5f" title="Intersects the current clipping region with another region.">reduceClipRegion()</a> and <a class="el" href="classGraphics.html#a9f6c05af33aefe49851d0d1eb9294bea" title="Moves the position of the context&#39;s origin.">setOrigin()</a> methods.</p>
<p>Obviously you shouldn't delete the image before this context is deleted. </p>

</div>
</div>
<a class="anchor" id="a7841c9a961ac9bca33bd30ddf8066cdb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraphics.html#a7841c9a961ac9bca33bd30ddf8066cdb">Graphics::~Graphics</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<a class="anchor" id="a1987cd53996367fd894885033ec39612"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraphics.html#ada6375a2e6bf68758a2191acb4d62c65">Graphics::Graphics</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLowLevelGraphicsContext.html">LowLevelGraphicsContext</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a graphics that uses a given low-level renderer. </p>
<p>For internal use only. NB. The context will NOT be deleted by this object when it is deleted. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af17c43bb97e6822aa4b7b8a8adc40b99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#af17c43bb97e6822aa4b7b8a8adc40b99">Graphics::setColour</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classColour.html">Colour</a> &amp;&#160;</td>
          <td class="paramname"><em>newColour</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the current drawing colour. </p>
<p>This sets the colour that will now be used for drawing operations - it also sets the opacity to that of the colour passed-in.</p>
<p>If a brush is being used when this method is called, the brush will be deselected, and any subsequent drawing will be done with a solid colour brush instead.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classGraphics.html#a1ce91a31ec1258a73ace93b6c337dbb2" title="Changes the opacity to use with the current colour.">setOpacity</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1ce91a31ec1258a73ace93b6c337dbb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a1ce91a31ec1258a73ace93b6c337dbb2">Graphics::setOpacity</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>newOpacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the opacity to use with the current colour. </p>
<p>If a solid colour is being used for drawing, this changes its opacity to this new value (i.e. it doesn't multiply the colour's opacity by this amount).</p>
<p>If a gradient is being used, this will have no effect on it.</p>
<p>A value of 0.0 is completely transparent, 1.0 is completely opaque. </p>

</div>
</div>
<a class="anchor" id="a57478bc2496ebb84696e5ba64b455965"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a57478bc2496ebb84696e5ba64b455965">Graphics::setGradientFill</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classColourGradient.html">ColourGradient</a> &amp;&#160;</td>
          <td class="paramname"><em>gradient</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the context to use a gradient for its fill pattern. </p>

</div>
</div>
<a class="anchor" id="a675cd4c4715165f0a0aec0bd8c3fe390"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a675cd4c4715165f0a0aec0bd8c3fe390">Graphics::setTiledImageFill</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classImage.html">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>imageToUse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>anchorX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>anchorY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>opacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the context to use a tiled image pattern for filling. </p>
<p>Make sure that you don't delete this image while it's still being used by this context! </p>

</div>
</div>
<a class="anchor" id="a763ea233d7b7c8e45e33c7ea8030ff48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a763ea233d7b7c8e45e33c7ea8030ff48">Graphics::setFillType</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFillType.html">FillType</a> &amp;&#160;</td>
          <td class="paramname"><em>newFill</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the current fill settings. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classGraphics.html#af17c43bb97e6822aa4b7b8a8adc40b99" title="Changes the current drawing colour.">setColour</a>, <a class="el" href="classGraphics.html#a57478bc2496ebb84696e5ba64b455965" title="Sets the context to use a gradient for its fill pattern.">setGradientFill</a>, <a class="el" href="classGraphics.html#a675cd4c4715165f0a0aec0bd8c3fe390" title="Sets the context to use a tiled image pattern for filling.">setTiledImageFill</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1fbdb321975d90c45243027a61ac2be9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a1fbdb321975d90c45243027a61ac2be9">Graphics::setFont</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFont.html">Font</a> &amp;&#160;</td>
          <td class="paramname"><em>newFont</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the font to use for subsequent text-drawing functions. </p>
<p>Note there's also a setFont (float, int) method to quickly change the size and style of the current font.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classGraphics.html#ade61955c11b56c91232b350dbfbf1b81" title="Draws a one-line text string.">drawSingleLineText</a>, <a class="el" href="classGraphics.html#a37c017a9d2f32bcd677f61f5de97ab9a" title="Draws text across multiple lines.">drawMultiLineText</a>, <a class="el" href="classGraphics.html#a837821b4bab764d76df560350e069b45" title="Renders a string of text as a vector path.">drawTextAsPath</a>, <a class="el" href="classGraphics.html#aa03c871748cf584b548663b79da7926c" title="Draws a line of text within a specified rectangle.">drawText</a>, <a class="el" href="classGraphics.html#ad2c56e11c42bc7404233b9a23e939ede" title="Tries to draw a text string inside a given space.">drawFittedText</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8c9a73240eab843cbf93393956910e72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a1fbdb321975d90c45243027a61ac2be9">Graphics::setFont</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>newFontHeight</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the size of the currently-selected font. </p>
<p>This is a convenient shortcut that changes the context's current font to a different size. The typeface won't be changed. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classFont.html" title="Represents a particular font, including its size, style, etc.">Font</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abb972f0d801630b6e02d335cfa9da28a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFont.html">Font</a> <a class="el" href="classGraphics.html#abb972f0d801630b6e02d335cfa9da28a">Graphics::getCurrentFont</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the currently selected font. </p>

</div>
</div>
<a class="anchor" id="ade61955c11b56c91232b350dbfbf1b81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#ade61955c11b56c91232b350dbfbf1b81">Graphics::drawSingleLineText</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classString.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baselineY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classJustification.html">Justification</a> &amp;&#160;</td>
          <td class="paramname"><em>justification</em> = <code><a class="el" href="classJustification.html#a2e0d86f7f4f1a05b0581af05d70e84bda56156bb2892e32febf8011af9c5da653">Justification::left</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws a one-line text string. </p>
<p>This will use the current colour (or brush) to fill the text. The font is the last one specified by <a class="el" href="classGraphics.html#a1fbdb321975d90c45243027a61ac2be9" title="Changes the font to use for subsequent text-drawing functions.">setFont()</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>the string to draw </td></tr>
    <tr><td class="paramname">startX</td><td>the position to draw the left-hand edge of the text </td></tr>
    <tr><td class="paramname">baselineY</td><td>the position of the text's baseline </td></tr>
    <tr><td class="paramname">justification</td><td>the horizontal flags indicate which end of the text string is anchored at the specified point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classGraphics.html#a37c017a9d2f32bcd677f61f5de97ab9a" title="Draws text across multiple lines.">drawMultiLineText</a>, <a class="el" href="classGraphics.html#aa03c871748cf584b548663b79da7926c" title="Draws a line of text within a specified rectangle.">drawText</a>, <a class="el" href="classGraphics.html#ad2c56e11c42bc7404233b9a23e939ede" title="Tries to draw a text string inside a given space.">drawFittedText</a>, <a class="el" href="classGlyphArrangement.html#a0ace103d7c4b6600dcea7aff1f26811d" title="Appends a line of text to the arrangement.">GlyphArrangement::addLineOfText</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a37c017a9d2f32bcd677f61f5de97ab9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a37c017a9d2f32bcd677f61f5de97ab9a">Graphics::drawMultiLineText</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classString.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>baselineY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maximumLineWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws text across multiple lines. </p>
<p>This will break the text onto a new line where there's a new-line or carriage-return character, or at a word-boundary when the text becomes wider than the size specified by the maximumLineWidth parameter.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classGraphics.html#a1fbdb321975d90c45243027a61ac2be9" title="Changes the font to use for subsequent text-drawing functions.">setFont</a>, <a class="el" href="classGraphics.html#ade61955c11b56c91232b350dbfbf1b81" title="Draws a one-line text string.">drawSingleLineText</a>, <a class="el" href="classGraphics.html#ad2c56e11c42bc7404233b9a23e939ede" title="Tries to draw a text string inside a given space.">drawFittedText</a>, <a class="el" href="classGlyphArrangement.html#a5cc600b28d93cb972baf14d3be08859f" title="Adds some multi-line text, breaking lines at word-boundaries if they are too wide.">GlyphArrangement::addJustifiedText</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a837821b4bab764d76df560350e069b45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a837821b4bab764d76df560350e069b45">Graphics::drawTextAsPath</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classString.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineTransform.html">AffineTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Renders a string of text as a vector path. </p>
<p>This allows a string to be transformed with an arbitrary <a class="el" href="classAffineTransform.html" title="Represents a 2D affine-transformation matrix.">AffineTransform</a> and rendered using the current colour/brush. It's much slower than the normal text methods but more accurate.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classGraphics.html#a1fbdb321975d90c45243027a61ac2be9" title="Changes the font to use for subsequent text-drawing functions.">setFont</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa03c871748cf584b548663b79da7926c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#aa03c871748cf584b548663b79da7926c">Graphics::drawText</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classString.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classJustification.html">Justification</a> &amp;&#160;</td>
          <td class="paramname"><em>justificationType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useEllipsesIfTooBig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws a line of text within a specified rectangle. </p>
<p>The text will be positioned within the rectangle based on the justification flags passed-in. If the string is too long to fit inside the rectangle, it will either be truncated or will have ellipsis added to its end (if the useEllipsesIfTooBig flag is true).</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classGraphics.html#ade61955c11b56c91232b350dbfbf1b81" title="Draws a one-line text string.">drawSingleLineText</a>, <a class="el" href="classGraphics.html#ad2c56e11c42bc7404233b9a23e939ede" title="Tries to draw a text string inside a given space.">drawFittedText</a>, <a class="el" href="classGraphics.html#a37c017a9d2f32bcd677f61f5de97ab9a" title="Draws text across multiple lines.">drawMultiLineText</a>, <a class="el" href="classGlyphArrangement.html#a5cc600b28d93cb972baf14d3be08859f" title="Adds some multi-line text, breaking lines at word-boundaries if they are too wide.">GlyphArrangement::addJustifiedText</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a84311fce34d51ada6738d3118f38a0b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#aa03c871748cf584b548663b79da7926c">Graphics::drawText</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classString.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRectangle.html">Rectangle</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classJustification.html">Justification</a> &amp;&#160;</td>
          <td class="paramname"><em>justificationType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useEllipsesIfTooBig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws a line of text within a specified rectangle. </p>
<p>The text will be positioned within the rectangle based on the justification flags passed-in. If the string is too long to fit inside the rectangle, it will either be truncated or will have ellipsis added to its end (if the useEllipsesIfTooBig flag is true).</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classGraphics.html#ade61955c11b56c91232b350dbfbf1b81" title="Draws a one-line text string.">drawSingleLineText</a>, <a class="el" href="classGraphics.html#ad2c56e11c42bc7404233b9a23e939ede" title="Tries to draw a text string inside a given space.">drawFittedText</a>, <a class="el" href="classGraphics.html#a37c017a9d2f32bcd677f61f5de97ab9a" title="Draws text across multiple lines.">drawMultiLineText</a>, <a class="el" href="classGlyphArrangement.html#a5cc600b28d93cb972baf14d3be08859f" title="Adds some multi-line text, breaking lines at word-boundaries if they are too wide.">GlyphArrangement::addJustifiedText</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad2c56e11c42bc7404233b9a23e939ede"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#ad2c56e11c42bc7404233b9a23e939ede">Graphics::drawFittedText</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classString.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classJustification.html">Justification</a> &amp;&#160;</td>
          <td class="paramname"><em>justificationFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maximumNumberOfLines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minimumHorizontalScale</em> = <code>0.7f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to draw a text string inside a given space. </p>
<p>This does its best to make the given text readable within the specified rectangle, so it useful for labelling things.</p>
<p>If the text is too big, it'll be squashed horizontally or broken over multiple lines if the maximumLinesToUse value allows this. If the text just won't fit into the space, it'll cram as much as possible in there, and put some ellipsis at the end to show that it's been truncated.</p>
<p>A <a class="el" href="classJustification.html" title="Represents a type of justification to be used when positioning graphical items.">Justification</a> parameter lets you specify how the text is laid out within the rectangle, both horizontally and vertically.</p>
<p>The minimumHorizontalScale parameter specifies how much the text can be squashed horizontally to try to squeeze it into the space. If you don't want any horizontal scaling to occur, you can set this value to 1.0f.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classGlyphArrangement.html#a18cfbfb3481a8f6d498e58be4f1c438b" title="Tries to fit some text withing a given space.">GlyphArrangement::addFittedText</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a278d7ad0e7697198003e2393d2331eb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#ad2c56e11c42bc7404233b9a23e939ede">Graphics::drawFittedText</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classString.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRectangle.html">Rectangle</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classJustification.html">Justification</a> &amp;&#160;</td>
          <td class="paramname"><em>justificationFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maximumNumberOfLines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minimumHorizontalScale</em> = <code>0.7f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to draw a text string inside a given space. </p>
<p>This does its best to make the given text readable within the specified rectangle, so it useful for labelling things.</p>
<p>If the text is too big, it'll be squashed horizontally or broken over multiple lines if the maximumLinesToUse value allows this. If the text just won't fit into the space, it'll cram as much as possible in there, and put some ellipsis at the end to show that it's been truncated.</p>
<p>A <a class="el" href="classJustification.html" title="Represents a type of justification to be used when positioning graphical items.">Justification</a> parameter lets you specify how the text is laid out within the rectangle, both horizontally and vertically.</p>
<p>The minimumHorizontalScale parameter specifies how much the text can be squashed horizontally to try to squeeze it into the space. If you don't want any horizontal scaling to occur, you can set this value to 1.0f.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classGlyphArrangement.html#a18cfbfb3481a8f6d498e58be4f1c438b" title="Tries to fit some text withing a given space.">GlyphArrangement::addFittedText</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a516a7795e6e0c6c70eb982a83ea0b8c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a516a7795e6e0c6c70eb982a83ea0b8c3">Graphics::fillAll</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills the context's entire clip region with the current colour or brush. </p>
<p>(See also the fillAll (const <a class="el" href="classColour.html" title="Represents a colour, also including a transparency value.">Colour</a>&amp;) method which is a quick way of filling it with a given colour). </p>

</div>
</div>
<a class="anchor" id="a29e9bc174cf54be0f423172e24d5cf78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a516a7795e6e0c6c70eb982a83ea0b8c3">Graphics::fillAll</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classColour.html">Colour</a> &amp;&#160;</td>
          <td class="paramname"><em>colourToUse</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills the context's entire clip region with a given colour. </p>
<p>This leaves the context's current colour and brush unchanged, it just uses the specified colour temporarily. </p>

</div>
</div>
<a class="anchor" id="ac2202ef993b53d77d8646ed4ce3ea9d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#ac2202ef993b53d77d8646ed4ce3ea9d1">Graphics::fillRect</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a rectangle with the current colour or brush. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classGraphics.html#a28baf90f8e11ec6f96c349f45e09a9d0" title="Draws four lines to form a rectangular outline, using the current colour or brush.">drawRect</a>, <a class="el" href="classGraphics.html#a1049a2dae8a1ae3e5e57238f2fd36a84" title="Uses the current colour or brush to fill a rectangle with rounded corners.">fillRoundedRectangle</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9ff78524c757a302ad8b9cbc4c7ba851"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#ac2202ef993b53d77d8646ed4ce3ea9d1">Graphics::fillRect</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRectangle.html">Rectangle</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>rectangle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a rectangle with the current colour or brush. </p>

</div>
</div>
<a class="anchor" id="a018bffc13a318cb5e59d29b258313b8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#ac2202ef993b53d77d8646ed4ce3ea9d1">Graphics::fillRect</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a rectangle with the current colour or brush. </p>
<p>This uses sub-pixel positioning so is slower than the fillRect method which takes integer co-ordinates. </p>

</div>
</div>
<a class="anchor" id="a1049a2dae8a1ae3e5e57238f2fd36a84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a1049a2dae8a1ae3e5e57238f2fd36a84">Graphics::fillRoundedRectangle</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cornerSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uses the current colour or brush to fill a rectangle with rounded corners. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classGraphics.html#a78541e36136eb040c4b8c81d4b8db8dd" title="Uses the current colour or brush to draw the outline of a rectangle with rounded corners.">drawRoundedRectangle</a>, <a class="el" href="classPath.html#a501f83b0e323fe86d33c047f83451065" title="Adds a rectangle with rounded corners to the path.">Path::addRoundedRectangle</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afc06f32c228086e55876184176314bd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a1049a2dae8a1ae3e5e57238f2fd36a84">Graphics::fillRoundedRectangle</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRectangle.html">Rectangle</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>rectangle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cornerSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uses the current colour or brush to fill a rectangle with rounded corners. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classGraphics.html#a78541e36136eb040c4b8c81d4b8db8dd" title="Uses the current colour or brush to draw the outline of a rectangle with rounded corners.">drawRoundedRectangle</a>, <a class="el" href="classPath.html#a501f83b0e323fe86d33c047f83451065" title="Adds a rectangle with rounded corners to the path.">Path::addRoundedRectangle</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a359717e34bed0f5dfd2f3004b3cea19f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a359717e34bed0f5dfd2f3004b3cea19f">Graphics::fillCheckerBoard</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRectangle.html">Rectangle</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>checkWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>checkHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classColour.html">Colour</a> &amp;&#160;</td>
          <td class="paramname"><em>colour1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classColour.html">Colour</a> &amp;&#160;</td>
          <td class="paramname"><em>colour2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a rectangle with a checkerboard pattern, alternating between two colours. </p>

</div>
</div>
<a class="anchor" id="a28baf90f8e11ec6f96c349f45e09a9d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a28baf90f8e11ec6f96c349f45e09a9d0">Graphics::drawRect</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineThickness</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws four lines to form a rectangular outline, using the current colour or brush. </p>
<p>The lines are drawn inside the given rectangle, and greater line thicknesses extend inwards.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classGraphics.html#ac2202ef993b53d77d8646ed4ce3ea9d1" title="Fills a rectangle with the current colour or brush.">fillRect</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7b8a15c73c5d797cd169852224236f4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a28baf90f8e11ec6f96c349f45e09a9d0">Graphics::drawRect</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lineThickness</em> = <code>1.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws four lines to form a rectangular outline, using the current colour or brush. </p>
<p>The lines are drawn inside the given rectangle, and greater line thicknesses extend inwards.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classGraphics.html#ac2202ef993b53d77d8646ed4ce3ea9d1" title="Fills a rectangle with the current colour or brush.">fillRect</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a88e7c28b48c3f2e9e2c9df7d2571908f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a28baf90f8e11ec6f96c349f45e09a9d0">Graphics::drawRect</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRectangle.html">Rectangle</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>rectangle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lineThickness</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws four lines to form a rectangular outline, using the current colour or brush. </p>
<p>The lines are drawn inside the given rectangle, and greater line thicknesses extend inwards.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classGraphics.html#ac2202ef993b53d77d8646ed4ce3ea9d1" title="Fills a rectangle with the current colour or brush.">fillRect</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a78541e36136eb040c4b8c81d4b8db8dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a78541e36136eb040c4b8c81d4b8db8dd">Graphics::drawRoundedRectangle</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cornerSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lineThickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uses the current colour or brush to draw the outline of a rectangle with rounded corners. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classGraphics.html#a1049a2dae8a1ae3e5e57238f2fd36a84" title="Uses the current colour or brush to fill a rectangle with rounded corners.">fillRoundedRectangle</a>, <a class="el" href="classPath.html#a501f83b0e323fe86d33c047f83451065" title="Adds a rectangle with rounded corners to the path.">Path::addRoundedRectangle</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a91706e86b7120523346fee8f2161d48f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a78541e36136eb040c4b8c81d4b8db8dd">Graphics::drawRoundedRectangle</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRectangle.html">Rectangle</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>rectangle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cornerSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lineThickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uses the current colour or brush to draw the outline of a rectangle with rounded corners. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classGraphics.html#a1049a2dae8a1ae3e5e57238f2fd36a84" title="Uses the current colour or brush to fill a rectangle with rounded corners.">fillRoundedRectangle</a>, <a class="el" href="classPath.html#a501f83b0e323fe86d33c047f83451065" title="Adds a rectangle with rounded corners to the path.">Path::addRoundedRectangle</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a69e70db1afc03d58f9055f8f45d8e5d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a69e70db1afc03d58f9055f8f45d8e5d1">Graphics::setPixel</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws a 1x1 pixel using the current colour or brush. </p>

</div>
</div>
<a class="anchor" id="ab6fdfd1cb32b32d52b6b30df36321f70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#ab6fdfd1cb32b32d52b6b30df36321f70">Graphics::fillEllipse</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills an ellipse with the current colour or brush. </p>
<p>The ellipse is drawn to fit inside the given rectangle. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classGraphics.html#ac88110d5407539aa1be841a89d5170b0" title="Draws an elliptical stroke using the current colour or brush.">drawEllipse</a>, <a class="el" href="classPath.html#a7514c5eaa928b64121490a7f0ce3088c" title="Adds an ellipse to the path.">Path::addEllipse</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4f58ce68f75ec835a4863e756ec11bed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#ab6fdfd1cb32b32d52b6b30df36321f70">Graphics::fillEllipse</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRectangle.html">Rectangle</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>area</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills an ellipse with the current colour or brush. </p>
<p>The ellipse is drawn to fit inside the given rectangle. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classGraphics.html#ac88110d5407539aa1be841a89d5170b0" title="Draws an elliptical stroke using the current colour or brush.">drawEllipse</a>, <a class="el" href="classPath.html#a7514c5eaa928b64121490a7f0ce3088c" title="Adds an ellipse to the path.">Path::addEllipse</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac88110d5407539aa1be841a89d5170b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#ac88110d5407539aa1be841a89d5170b0">Graphics::drawEllipse</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lineThickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws an elliptical stroke using the current colour or brush. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classGraphics.html#ab6fdfd1cb32b32d52b6b30df36321f70" title="Fills an ellipse with the current colour or brush.">fillEllipse</a>, <a class="el" href="classPath.html#a7514c5eaa928b64121490a7f0ce3088c" title="Adds an ellipse to the path.">Path::addEllipse</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0911bf63fd6c0d3e35b2b701fcbc7728"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a0911bf63fd6c0d3e35b2b701fcbc7728">Graphics::drawLine</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>startX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>startY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>endX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>endY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws a line between two points. </p>
<p>The line is 1 pixel wide and drawn with the current colour or brush. </p>

</div>
</div>
<a class="anchor" id="a664643f9fef3c8b37b0620c28ec4bb76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a0911bf63fd6c0d3e35b2b701fcbc7728">Graphics::drawLine</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>startX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>startY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>endX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>endY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lineThickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws a line between two points with a given thickness. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classPath.html#a93c4d70100bed1ea07518fea36267035" title="Adds a line with a specified thickness.">Path::addLineSegment</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a94cf6a3a058ad1a36dc836b34916ef0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a0911bf63fd6c0d3e35b2b701fcbc7728">Graphics::drawLine</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLine.html">Line</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws a line between two points. </p>
<p>The line is 1 pixel wide and drawn with the current colour or brush. </p>

</div>
</div>
<a class="anchor" id="ace7c180c66f119399acb69ad966057e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a0911bf63fd6c0d3e35b2b701fcbc7728">Graphics::drawLine</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLine.html">Line</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lineThickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws a line between two points with a given thickness. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classPath.html#a93c4d70100bed1ea07518fea36267035" title="Adds a line with a specified thickness.">Path::addLineSegment</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab24a3f2ba3d648285fcad7c97fb8270f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#ab24a3f2ba3d648285fcad7c97fb8270f">Graphics::drawDashedLine</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLine.html">Line</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>dashLengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numDashLengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lineThickness</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dashIndexToStartFrom</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws a dashed line using a custom set of dash-lengths. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>the line to draw </td></tr>
    <tr><td class="paramname">dashLengths</td><td>a series of lengths to specify the on/off lengths - e.g. { 4, 5, 6, 7 } will draw a line of 4 pixels, skip 5 pixels, draw 6 pixels, skip 7 pixels, and then repeat. </td></tr>
    <tr><td class="paramname">numDashLengths</td><td>the number of elements in the array (this must be an even number). </td></tr>
    <tr><td class="paramname">lineThickness</td><td>the thickness of the line to draw </td></tr>
    <tr><td class="paramname">dashIndexToStartFrom</td><td>the index in the dash-length array to use for the first segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classPathStrokeType.html#a4eca56bfcdc41f774fcde1c8e34b70af" title="Applies this stroke type to a path, creating a dashed line.">PathStrokeType::createDashedStroke</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a042d4f7223a63212ae1d9452e26cbd7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a042d4f7223a63212ae1d9452e26cbd7a">Graphics::drawVerticalLine</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bottom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws a vertical line of pixels at a given x position. </p>
<p>The x position is an integer, but the top and bottom of the line can be sub-pixel positions, and these will be anti-aliased if necessary.</p>
<p>The bottom parameter must be greater than or equal to the top parameter. </p>

</div>
</div>
<a class="anchor" id="aeea9ba47ff90bb7643038692bf647738"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#aeea9ba47ff90bb7643038692bf647738">Graphics::drawHorizontalLine</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws a horizontal line of pixels at a given y position. </p>
<p>The y position is an integer, but the left and right ends of the line can be sub-pixel positions, and these will be anti-aliased if necessary.</p>
<p>The right parameter must be greater than or equal to the left parameter. </p>

</div>
</div>
<a class="anchor" id="a129aa4c9dcc137a1c910a2f5ef118fb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a129aa4c9dcc137a1c910a2f5ef118fb7">Graphics::fillPath</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPath.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineTransform.html">AffineTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em> = <code><a class="el" href="classAffineTransform.html#a2173017e6300f667a23467505ca36276">AffineTransform::identity</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills a path using the currently selected colour or brush. </p>

</div>
</div>
<a class="anchor" id="a5bd626168d02b83d10123e398da5c5a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a5bd626168d02b83d10123e398da5c5a7">Graphics::strokePath</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPath.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPathStrokeType.html">PathStrokeType</a> &amp;&#160;</td>
          <td class="paramname"><em>strokeType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineTransform.html">AffineTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em> = <code><a class="el" href="classAffineTransform.html#a2173017e6300f667a23467505ca36276">AffineTransform::identity</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws a path's outline using the currently selected colour or brush. </p>

</div>
</div>
<a class="anchor" id="ab1484b102f99384c443cfb5881d68fa9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#ab1484b102f99384c443cfb5881d68fa9">Graphics::drawArrow</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLine.html">Line</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lineThickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arrowheadWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>arrowheadLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws a line with an arrowhead at its end. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>the line to draw </td></tr>
    <tr><td class="paramname">lineThickness</td><td>the thickness of the line </td></tr>
    <tr><td class="paramname">arrowheadWidth</td><td>the width of the arrow head (perpendicular to the line) </td></tr>
    <tr><td class="paramname">arrowheadLength</td><td>the length of the arrow head (along the length of the line) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0f8160f9b0a6866e40cf1a2b45c3b892"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a0f8160f9b0a6866e40cf1a2b45c3b892">Graphics::setImageResamplingQuality</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGraphics.html#a5da218e649d1b5ac3d67443ae77caf87">ResamplingQuality</a>&#160;</td>
          <td class="paramname"><em>newQuality</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes the quality that will be used when resampling images. </p>
<p>By default a <a class="el" href="classGraphics.html" title="A graphics context, used for drawing a component or image.">Graphics</a> object will be set to mediumRenderingQuality.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classGraphics.html#a6e09218805a3eb3f7d4973433647d0e9" title="Draws part of an image, rescaling it to fit in a given target region.">Graphics::drawImage</a>, <a class="el" href="classGraphics.html#a79c4f544cd7fcada2be7d24691e157a3" title="Draws an image, having applied an affine transform to it.">Graphics::drawImageTransformed</a>, <a class="el" href="classGraphics.html#a980e4beef03333ee1ec1ca7b7963ad63" title="Draws an image to fit within a designated rectangle.">Graphics::drawImageWithin</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab754b6a67c6964be2d27b1ba82bdae56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#ab754b6a67c6964be2d27b1ba82bdae56">Graphics::drawImageAt</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classImage.html">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>imageToDraw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>topLeftX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>topLeftY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fillAlphaChannelWithCurrentBrush</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws an image. </p>
<p>This will draw the whole of an image, positioning its top-left corner at the given co-ordinates, and keeping its size the same. This is the simplest image drawing method - the others give more control over the scaling and clipping of the images.</p>
<p>Images are composited using the context's current opacity, so if you don't want it to be drawn semi-transparently, be sure to call setOpacity (1.0f) (or <a class="el" href="classGraphics.html#af17c43bb97e6822aa4b7b8a8adc40b99" title="Changes the current drawing colour.">setColour()</a> with an opaque colour) before drawing images. </p>

</div>
</div>
<a class="anchor" id="a6e09218805a3eb3f7d4973433647d0e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a6e09218805a3eb3f7d4973433647d0e9">Graphics::drawImage</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classImage.html">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>imageToDraw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sourceX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sourceY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sourceWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sourceHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fillAlphaChannelWithCurrentBrush</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws part of an image, rescaling it to fit in a given target region. </p>
<p>The specified area of the source image is rescaled and drawn to fill the specifed destination rectangle.</p>
<p>Images are composited using the context's current opacity, so if you don't want it to be drawn semi-transparently, be sure to call setOpacity (1.0f) (or <a class="el" href="classGraphics.html#af17c43bb97e6822aa4b7b8a8adc40b99" title="Changes the current drawing colour.">setColour()</a> with an opaque colour) before drawing images.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">imageToDraw</td><td>the image to overlay </td></tr>
    <tr><td class="paramname">destX</td><td>the left of the destination rectangle </td></tr>
    <tr><td class="paramname">destY</td><td>the top of the destination rectangle </td></tr>
    <tr><td class="paramname">destWidth</td><td>the width of the destination rectangle </td></tr>
    <tr><td class="paramname">destHeight</td><td>the height of the destination rectangle </td></tr>
    <tr><td class="paramname">sourceX</td><td>the left of the rectangle to copy from the source image </td></tr>
    <tr><td class="paramname">sourceY</td><td>the top of the rectangle to copy from the source image </td></tr>
    <tr><td class="paramname">sourceWidth</td><td>the width of the rectangle to copy from the source image </td></tr>
    <tr><td class="paramname">sourceHeight</td><td>the height of the rectangle to copy from the source image </td></tr>
    <tr><td class="paramname">fillAlphaChannelWithCurrentBrush</td><td>if true, then instead of drawing the source image's pixels, the source image's alpha channel is used as a mask with which to fill the destination using the current colour or brush. (If the source is has no alpha channel, then it will just fill the target with a solid rectangle) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classGraphics.html#a0f8160f9b0a6866e40cf1a2b45c3b892" title="Changes the quality that will be used when resampling images.">setImageResamplingQuality</a>, <a class="el" href="classGraphics.html#ab754b6a67c6964be2d27b1ba82bdae56" title="Draws an image.">drawImageAt</a>, <a class="el" href="classGraphics.html#a980e4beef03333ee1ec1ca7b7963ad63" title="Draws an image to fit within a designated rectangle.">drawImageWithin</a>, fillAlphaMap </dd></dl>

</div>
</div>
<a class="anchor" id="a79c4f544cd7fcada2be7d24691e157a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a79c4f544cd7fcada2be7d24691e157a3">Graphics::drawImageTransformed</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classImage.html">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>imageToDraw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineTransform.html">AffineTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fillAlphaChannelWithCurrentBrush</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws an image, having applied an affine transform to it. </p>
<p>This lets you throw the image around in some wacky ways, rotate it, shear, scale it, etc.</p>
<p>Images are composited using the context's current opacity, so if you don't want it to be drawn semi-transparently, be sure to call setOpacity (1.0f) (or <a class="el" href="classGraphics.html#af17c43bb97e6822aa4b7b8a8adc40b99" title="Changes the current drawing colour.">setColour()</a> with an opaque colour) before drawing images.</p>
<p>If fillAlphaChannelWithCurrentBrush is set to true, then the image's RGB channels are ignored and it is filled with the current brush, masked by its alpha channel.</p>
<p>If you want to render only a subsection of an image, use <a class="el" href="classImage.html#a23f8ff9b07d67f2c60776d4031c27417" title="Returns an image which refers to a subsection of this image.">Image::getClippedImage()</a> to create the section that you need.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classGraphics.html#a0f8160f9b0a6866e40cf1a2b45c3b892" title="Changes the quality that will be used when resampling images.">setImageResamplingQuality</a>, <a class="el" href="classGraphics.html#a6e09218805a3eb3f7d4973433647d0e9" title="Draws part of an image, rescaling it to fit in a given target region.">drawImage</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a980e4beef03333ee1ec1ca7b7963ad63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a980e4beef03333ee1ec1ca7b7963ad63">Graphics::drawImageWithin</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classImage.html">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>imageToDraw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRectanglePlacement.html">RectanglePlacement</a> &amp;&#160;</td>
          <td class="paramname"><em>placementWithinTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fillAlphaChannelWithCurrentBrush</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Draws an image to fit within a designated rectangle. </p>
<p>If the image is too big or too small for the space, it will be rescaled to fit as nicely as it can do without affecting its aspect ratio. It will then be placed within the target rectangle according to the justification flags specified.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">imageToDraw</td><td>the source image to draw </td></tr>
    <tr><td class="paramname">destX</td><td>top-left of the target rectangle to fit it into </td></tr>
    <tr><td class="paramname">destY</td><td>top-left of the target rectangle to fit it into </td></tr>
    <tr><td class="paramname">destWidth</td><td>size of the target rectangle to fit the image into </td></tr>
    <tr><td class="paramname">destHeight</td><td>size of the target rectangle to fit the image into </td></tr>
    <tr><td class="paramname">placementWithinTarget</td><td>this specifies how the image should be positioned within the target rectangle - see the <a class="el" href="classRectanglePlacement.html" title="Defines the method used to postion some kind of rectangular object within a rectangular viewport...">RectanglePlacement</a> class for more details about this. </td></tr>
    <tr><td class="paramname">fillAlphaChannelWithCurrentBrush</td><td>if true, then instead of drawing the image, just its alpha channel will be used as a mask with which to draw with the current brush or colour. This is similar to fillAlphaMap(), and see also <a class="el" href="classGraphics.html#a6e09218805a3eb3f7d4973433647d0e9" title="Draws part of an image, rescaling it to fit in a given target region.">drawImage()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classGraphics.html#a0f8160f9b0a6866e40cf1a2b45c3b892" title="Changes the quality that will be used when resampling images.">setImageResamplingQuality</a>, <a class="el" href="classGraphics.html#a6e09218805a3eb3f7d4973433647d0e9" title="Draws part of an image, rescaling it to fit in a given target region.">drawImage</a>, <a class="el" href="classGraphics.html#a79c4f544cd7fcada2be7d24691e157a3" title="Draws an image, having applied an affine transform to it.">drawImageTransformed</a>, <a class="el" href="classGraphics.html#ab754b6a67c6964be2d27b1ba82bdae56" title="Draws an image.">drawImageAt</a>, <a class="el" href="classRectanglePlacement.html" title="Defines the method used to postion some kind of rectangular object within a rectangular viewport...">RectanglePlacement</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a34942cbdbd743d7fd332c218ea7e4c5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRectangle.html">Rectangle</a>&lt;int&gt; <a class="el" href="classGraphics.html#a34942cbdbd743d7fd332c218ea7e4c5d">Graphics::getClipBounds</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the position of the bounding box for the current clipping region. </p>
<dl class="section see"><dt>See also:</dt><dd>getClipRegion, <a class="el" href="classGraphics.html#a0a91a1c322713e070d8fd42796854340" title="Checks whether a rectangle overlaps the context&#39;s clipping region.">clipRegionIntersects</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0a91a1c322713e070d8fd42796854340"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGraphics.html#a0a91a1c322713e070d8fd42796854340">Graphics::clipRegionIntersects</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRectangle.html">Rectangle</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>area</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks whether a rectangle overlaps the context's clipping region. </p>
<p>If this returns false, no part of the given area can be drawn onto, so this method can be used to optimise a component's paint() method, by letting it avoid drawing complex objects that aren't within the region being repainted. </p>

</div>
</div>
<a class="anchor" id="ad97e058fcff2bc0e634eacc4ef1d7a5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGraphics.html#ad97e058fcff2bc0e634eacc4ef1d7a5f">Graphics::reduceClipRegion</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Intersects the current clipping region with another region. </p>
<dl class="section return"><dt>Returns:</dt><dd>true if the resulting clipping region is non-zero in size </dd></dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classGraphics.html#a9f6c05af33aefe49851d0d1eb9294bea" title="Moves the position of the context&#39;s origin.">setOrigin</a>, <a class="el" href="classGraphics.html#a0a91a1c322713e070d8fd42796854340" title="Checks whether a rectangle overlaps the context&#39;s clipping region.">clipRegionIntersects</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a97cba43cb492f57590b5f211e590e38f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGraphics.html#ad97e058fcff2bc0e634eacc4ef1d7a5f">Graphics::reduceClipRegion</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRectangle.html">Rectangle</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>area</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Intersects the current clipping region with another region. </p>
<dl class="section return"><dt>Returns:</dt><dd>true if the resulting clipping region is non-zero in size </dd></dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classGraphics.html#a9f6c05af33aefe49851d0d1eb9294bea" title="Moves the position of the context&#39;s origin.">setOrigin</a>, <a class="el" href="classGraphics.html#a0a91a1c322713e070d8fd42796854340" title="Checks whether a rectangle overlaps the context&#39;s clipping region.">clipRegionIntersects</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae30c76ed849ef8a987cb98191e0668e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGraphics.html#ad97e058fcff2bc0e634eacc4ef1d7a5f">Graphics::reduceClipRegion</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRectangleList.html">RectangleList</a> &amp;&#160;</td>
          <td class="paramname"><em>clipRegion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Intersects the current clipping region with a rectangle list region. </p>
<dl class="section return"><dt>Returns:</dt><dd>true if the resulting clipping region is non-zero in size </dd></dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classGraphics.html#a9f6c05af33aefe49851d0d1eb9294bea" title="Moves the position of the context&#39;s origin.">setOrigin</a>, <a class="el" href="classGraphics.html#a0a91a1c322713e070d8fd42796854340" title="Checks whether a rectangle overlaps the context&#39;s clipping region.">clipRegionIntersects</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a01d830805b335f8cdf52fadd00bd0d30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGraphics.html#ad97e058fcff2bc0e634eacc4ef1d7a5f">Graphics::reduceClipRegion</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPath.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineTransform.html">AffineTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em> = <code><a class="el" href="classAffineTransform.html#a2173017e6300f667a23467505ca36276">AffineTransform::identity</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Intersects the current clipping region with a path. </p>
<dl class="section return"><dt>Returns:</dt><dd>true if the resulting clipping region is non-zero in size </dd></dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classGraphics.html#ad97e058fcff2bc0e634eacc4ef1d7a5f" title="Intersects the current clipping region with another region.">reduceClipRegion</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a735b5096ea063020134fdf1c570dec9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGraphics.html#ad97e058fcff2bc0e634eacc4ef1d7a5f">Graphics::reduceClipRegion</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classImage.html">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineTransform.html">AffineTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Intersects the current clipping region with an image's alpha-channel. </p>
<p>The current clipping path is intersected with the area covered by this image's alpha-channel, after the image has been transformed by the specified matrix.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>the image whose alpha-channel should be used. If the image doesn't have an alpha-channel, it is treated as entirely opaque. </td></tr>
    <tr><td class="paramname">transform</td><td>a matrix to apply to the image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>true if the resulting clipping region is non-zero in size </dd></dl>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classGraphics.html#ad97e058fcff2bc0e634eacc4ef1d7a5f" title="Intersects the current clipping region with another region.">reduceClipRegion</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9ff97378305763a38f4a99bc638a8824"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a9ff97378305763a38f4a99bc638a8824">Graphics::excludeClipRegion</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRectangle.html">Rectangle</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>rectangleToExclude</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Excludes a rectangle to stop it being drawn into. </p>

</div>
</div>
<a class="anchor" id="a6ae806601e19bc1631085d6e2a7f5d74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGraphics.html#a6ae806601e19bc1631085d6e2a7f5d74">Graphics::isClipEmpty</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if no drawing can be done because the clip region is zero. </p>

</div>
</div>
<a class="anchor" id="ab4df35938684890f7adac0439e900ca8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#ab4df35938684890f7adac0439e900ca8">Graphics::saveState</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Saves the current graphics state on an internal stack. </p>
<p>To restore the state, use <a class="el" href="classGraphics.html#ac724e99c9a7bcd8b2987a484e269a368" title="Restores a graphics state that was previously saved with saveState().">restoreState()</a>. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classGraphics_1_1ScopedSaveState.html" title="Uses RAII to save and restore the state of a graphics context.">ScopedSaveState</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac724e99c9a7bcd8b2987a484e269a368"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#ac724e99c9a7bcd8b2987a484e269a368">Graphics::restoreState</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Restores a graphics state that was previously saved with <a class="el" href="classGraphics.html#ab4df35938684890f7adac0439e900ca8" title="Saves the current graphics state on an internal stack.">saveState()</a>. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classGraphics_1_1ScopedSaveState.html" title="Uses RAII to save and restore the state of a graphics context.">ScopedSaveState</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab8d8ee1c6bb810074eff904fd3c21fc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#ab8d8ee1c6bb810074eff904fd3c21fc4">Graphics::beginTransparencyLayer</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>layerOpacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Begins rendering to an off-screen bitmap which will later be flattened onto the current context with the given opacity. </p>
<p>The context uses an internal stack of temporary image layers to do this. When you've finished drawing to the layer, call <a class="el" href="classGraphics.html#ae6b36ef8295dd83d33287a328e88ef9c" title="Completes a drawing operation to a temporary semi-transparent buffer.">endTransparencyLayer()</a> to complete the operation and composite the finished layer. Every call to <a class="el" href="classGraphics.html#ab8d8ee1c6bb810074eff904fd3c21fc4" title="Begins rendering to an off-screen bitmap which will later be flattened onto the current context with ...">beginTransparencyLayer()</a> MUST be matched by a corresponding call to <a class="el" href="classGraphics.html#ae6b36ef8295dd83d33287a328e88ef9c" title="Completes a drawing operation to a temporary semi-transparent buffer.">endTransparencyLayer()</a>!</p>
<p>This call also saves the current state, and <a class="el" href="classGraphics.html#ae6b36ef8295dd83d33287a328e88ef9c" title="Completes a drawing operation to a temporary semi-transparent buffer.">endTransparencyLayer()</a> restores it. </p>

</div>
</div>
<a class="anchor" id="ae6b36ef8295dd83d33287a328e88ef9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#ae6b36ef8295dd83d33287a328e88ef9c">Graphics::endTransparencyLayer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Completes a drawing operation to a temporary semi-transparent buffer. </p>
<p>See <a class="el" href="classGraphics.html#ab8d8ee1c6bb810074eff904fd3c21fc4" title="Begins rendering to an off-screen bitmap which will later be flattened onto the current context with ...">beginTransparencyLayer()</a> for more details. </p>

</div>
</div>
<a class="anchor" id="a9f6c05af33aefe49851d0d1eb9294bea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a9f6c05af33aefe49851d0d1eb9294bea">Graphics::setOrigin</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newOriginX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newOriginY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves the position of the context's origin. </p>
<p>This changes the position that the context considers to be (0, 0) to the specified position.</p>
<p>So if you call setOrigin (100, 100), then the position that was previously referred to as (100, 100) will subsequently be considered to be (0, 0).</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classGraphics.html#ad97e058fcff2bc0e634eacc4ef1d7a5f" title="Intersects the current clipping region with another region.">reduceClipRegion</a>, <a class="el" href="classGraphics.html#a7d9d400fdb96d3c6bbb640fb94b54d06" title="Adds a transformation which will be performed on all the graphics operations that the context subsequ...">addTransform</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7d9d400fdb96d3c6bbb640fb94b54d06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#a7d9d400fdb96d3c6bbb640fb94b54d06">Graphics::addTransform</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineTransform.html">AffineTransform</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a transformation which will be performed on all the graphics operations that the context subsequently performs. </p>
<p>After calling this, all the coordinates that are passed into the context will be transformed by this matrix.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="classGraphics.html#a9f6c05af33aefe49851d0d1eb9294bea" title="Moves the position of the context&#39;s origin.">setOrigin</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab8b7cd49bf1ff738c5ff848727e3bc75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraphics.html#ab8b7cd49bf1ff738c5ff848727e3bc75">Graphics::resetToDefaultState</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets the current colour, brush, and font to default settings. </p>

</div>
</div>
<a class="anchor" id="ae584e8878455891d9010addb384425cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGraphics.html#ae584e8878455891d9010addb384425cd">Graphics::isVectorDevice</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if this context is drawing to a vector-based device, such as a printer. </p>

</div>
</div>
<a class="anchor" id="a504995c303f45cce740dda9fa67f1a64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLowLevelGraphicsContext.html">LowLevelGraphicsContext</a>&amp; <a class="el" href="classGraphics.html#a504995c303f45cce740dda9fa67f1a64">Graphics::getInternalContext</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="juce__GraphicsContext_8h.html">juce_GraphicsContext.h</a></li>
</ul>
</div><!-- contents -->
<hr class="footer"/>
<address class="footer"><small>All content &copy Raw Material Software Ltd.</small></address><br/>
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-19759318-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
</html>
