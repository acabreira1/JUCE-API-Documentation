<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>JUCE: ValueTree Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">JUCE
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">ValueTree Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="ValueTree" -->
<p>A powerful tree structure that can be used to hold free-form data, and which can handle its own undo and redo behaviour.  
 <a href="classValueTree.html#details">More...</a></p>

<p><a href="classValueTree-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree_1_1Listener.html">Listener</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classValueTree_1_1Listener.html" title="Listener class for events that happen to a ValueTree.">Listener</a> class for events that happen to a <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a>.  <a href="classValueTree_1_1Listener.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#ad5671081941b3db9db42bf7fcbd2629c">ValueTree</a> () noexcept</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty, invalid <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a>.  <a href="#ad5671081941b3db9db42bf7fcbd2629c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#af2f66bc6973b9a7561af455bd6fb331c">ValueTree</a> (const <a class="el" href="classIdentifier.html">Identifier</a> &amp;type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> with the given type name.  <a href="#af2f66bc6973b9a7561af455bd6fb331c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a685fac19f67d8138645b6ccdb37f6809">ValueTree</a> (const <a class="el" href="classValueTree.html">ValueTree</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a reference to another <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a>.  <a href="#a685fac19f67d8138645b6ccdb37f6809"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classValueTree.html">ValueTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#abb0ec8b6af470fb80f5fb84d080cd26c">operator=</a> (const <a class="el" href="classValueTree.html">ValueTree</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes this object reference another node.  <a href="#abb0ec8b6af470fb80f5fb84d080cd26c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a4e0b4721cb1ec7f79c59192df3b97bcc">~ValueTree</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a4e0b4721cb1ec7f79c59192df3b97bcc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a078b2ccd7ffad9a0afd3c9d87c976aef">operator==</a> (const <a class="el" href="classValueTree.html">ValueTree</a> &amp;other) const noexcept</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if both this and the other tree node refer to the same underlying structure.  <a href="#a078b2ccd7ffad9a0afd3c9d87c976aef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a855f4a7a94f247b700e15d2ff7fd6436">operator!=</a> (const <a class="el" href="classValueTree.html">ValueTree</a> &amp;other) const noexcept</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this and the other node refer to different underlying structures.  <a href="#a855f4a7a94f247b700e15d2ff7fd6436"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#ac6f5b2c18a305fcc6a89e24e5834e298">isEquivalentTo</a> (const <a class="el" href="classValueTree.html">ValueTree</a> &amp;other) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a deep comparison between the properties and children of two trees.  <a href="#ac6f5b2c18a305fcc6a89e24e5834e298"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#afc7d5ea43143bafac840a8336c5301a5">isValid</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this node refers to some valid data.  <a href="#afc7d5ea43143bafac840a8336c5301a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classValueTree.html">ValueTree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#ad212f52a1dee540a97b256a57c881fed">createCopy</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a deep copy of this tree and all its sub-nodes.  <a href="#ad212f52a1dee540a97b256a57c881fed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIdentifier.html">Identifier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a877bc705ae6b3973d4af1b97f5e4c557">getType</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of this node.  <a href="#a877bc705ae6b3973d4af1b97f5e4c557"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#aa28f5bc26e2704dc725168e54789cff2">hasType</a> (const <a class="el" href="classIdentifier.html">Identifier</a> &amp;typeName) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node has this type.  <a href="#aa28f5bc26e2704dc725168e54789cff2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvar.html">var</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#ac7095a89f79cd50625e92fde56984268">getProperty</a> (const <a class="el" href="classIdentifier.html">Identifier</a> &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of a named property.  <a href="#ac7095a89f79cd50625e92fde56984268"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvar.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a37c064d4411df78b7d1d8ded5cac3ce3">getProperty</a> (const <a class="el" href="classIdentifier.html">Identifier</a> &amp;name, const <a class="el" href="classvar.html">var</a> &amp;defaultReturnValue) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of a named property, or a user-specified default if the property doesn't exist.  <a href="#a37c064d4411df78b7d1d8ded5cac3ce3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvar.html">var</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a1f5c73dc935caa6577e8e2c9a51b4c86">operator[]</a> (const <a class="el" href="classIdentifier.html">Identifier</a> &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of a named property.  <a href="#a1f5c73dc935caa6577e8e2c9a51b4c86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classValueTree.html">ValueTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#ad236114dc2a8c41c799f1fc51d1614bd">setProperty</a> (const <a class="el" href="classIdentifier.html">Identifier</a> &amp;name, const <a class="el" href="classvar.html">var</a> &amp;newValue, <a class="el" href="classUndoManager.html">UndoManager</a> *undoManager)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes a named property of the node.  <a href="#ad236114dc2a8c41c799f1fc51d1614bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a9dcb765aacb4f0f153fea6c311952d9b">hasProperty</a> (const <a class="el" href="classIdentifier.html">Identifier</a> &amp;name) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the node contains a named property.  <a href="#a9dcb765aacb4f0f153fea6c311952d9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a2a07b801bd317aa8bf1ee9da5644fc35">removeProperty</a> (const <a class="el" href="classIdentifier.html">Identifier</a> &amp;name, <a class="el" href="classUndoManager.html">UndoManager</a> *undoManager)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a property from the node.  <a href="#a2a07b801bd317aa8bf1ee9da5644fc35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a2f750331b6a680f48751302be9313467">removeAllProperties</a> (<a class="el" href="classUndoManager.html">UndoManager</a> *undoManager)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all properties from the node.  <a href="#a2f750331b6a680f48751302be9313467"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#ac83190970c072ff95edaebd1ade65c93">getNumProperties</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of properties that the node contains.  <a href="#ac83190970c072ff95edaebd1ade65c93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIdentifier.html">Identifier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a14517f03840bf3fe5e2cdfc5c2f07588">getPropertyName</a> (int index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the identifier of the property with a given index.  <a href="#a14517f03840bf3fe5e2cdfc5c2f07588"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classValue.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#aa36d40c533583c723be757c77ade1a5c">getPropertyAsValue</a> (const <a class="el" href="classIdentifier.html">Identifier</a> &amp;name, <a class="el" href="classUndoManager.html">UndoManager</a> *undoManager)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classValue.html" title="Represents a shared variant value.">Value</a> object that can be used to control and respond to one of the tree's properties.  <a href="#aa36d40c533583c723be757c77ade1a5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#ab4e869902306be8d60d056a4192383c2">getNumChildren</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of child nodes belonging to this one.  <a href="#ab4e869902306be8d60d056a4192383c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classValueTree.html">ValueTree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#ae3c7ef24e903b145e7885820898240cb">getChild</a> (int index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one of this node's child nodes.  <a href="#ae3c7ef24e903b145e7885820898240cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classValueTree.html">ValueTree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a00e9d09ad2439b9eb5cb79cb146c5a73">getChildWithName</a> (const <a class="el" href="classIdentifier.html">Identifier</a> &amp;type) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first child node with the speficied type name.  <a href="#a00e9d09ad2439b9eb5cb79cb146c5a73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classValueTree.html">ValueTree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#aafb29876616f005939915de3e6968818">getOrCreateChildWithName</a> (const <a class="el" href="classIdentifier.html">Identifier</a> &amp;type, <a class="el" href="classUndoManager.html">UndoManager</a> *undoManager)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first child node with the speficied type name, creating and adding a child with this name if there wasn't already one there.  <a href="#aafb29876616f005939915de3e6968818"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classValueTree.html">ValueTree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a99c2e890ecbed6c7fab83c1a95d824a6">getChildWithProperty</a> (const <a class="el" href="classIdentifier.html">Identifier</a> &amp;propertyName, const <a class="el" href="classvar.html">var</a> &amp;propertyValue) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for the first child node that has the speficied property value.  <a href="#a99c2e890ecbed6c7fab83c1a95d824a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a93d639299ef9dfedc651544e05f06693">addChild</a> (const <a class="el" href="classValueTree.html">ValueTree</a> &amp;child, int index, <a class="el" href="classUndoManager.html">UndoManager</a> *undoManager)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a child to this node.  <a href="#a93d639299ef9dfedc651544e05f06693"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a52b15bdb0b4a04b81c04e7059bb926c4">removeChild</a> (const <a class="el" href="classValueTree.html">ValueTree</a> &amp;child, <a class="el" href="classUndoManager.html">UndoManager</a> *undoManager)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified child from this node's child-list.  <a href="#a52b15bdb0b4a04b81c04e7059bb926c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a3bee3734652dec6bb1d5c351a1268fc0">removeChild</a> (int childIndex, <a class="el" href="classUndoManager.html">UndoManager</a> *undoManager)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a child from this node's child-list.  <a href="#a3bee3734652dec6bb1d5c351a1268fc0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a91f8a28e02a782b0c95f855d0c29f0d9">removeAllChildren</a> (<a class="el" href="classUndoManager.html">UndoManager</a> *undoManager)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all child-nodes from this node.  <a href="#a91f8a28e02a782b0c95f855d0c29f0d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#ab7d20bf6964bfc8c4a975543bca8ce53">moveChild</a> (int currentIndex, int newIndex, <a class="el" href="classUndoManager.html">UndoManager</a> *undoManager)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves one of the children to a different index.  <a href="#ab7d20bf6964bfc8c4a975543bca8ce53"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#af55de3861c98a6441e04891690784eff">isAChildOf</a> (const <a class="el" href="classValueTree.html">ValueTree</a> &amp;possibleParent) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this node is anywhere below the specified parent node.  <a href="#af55de3861c98a6441e04891690784eff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#aed934c5a006a21f8edf4c1b7fe39bc48">indexOf</a> (const <a class="el" href="classValueTree.html">ValueTree</a> &amp;child) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of a child item in this parent.  <a href="#aed934c5a006a21f8edf4c1b7fe39bc48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classValueTree.html">ValueTree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a238a440b17653c87e1b0981515bc2bfa">getParent</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parent node that contains this one.  <a href="#a238a440b17653c87e1b0981515bc2bfa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classValueTree.html">ValueTree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#aeaad7cad64013775bdf12b871c07abb7">getSibling</a> (int delta) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one of this node's siblings in its parent's child list.  <a href="#aeaad7cad64013775bdf12b871c07abb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXmlElement.html">XmlElement</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#ad4b6941292f6ba19b1f4c7a91b82f957">createXml</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="classXmlElement.html" title="Used to build a tree of elements representing an XML document.">XmlElement</a> that holds a complete image of this node and all its children.  <a href="#ad4b6941292f6ba19b1f4c7a91b82f957"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a4030330dde3b8e95e706336627d278c3">writeToStream</a> (<a class="el" href="classOutputStream.html">OutputStream</a> &amp;output)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores this tree (and all its children) in a binary format.  <a href="#a4030330dde3b8e95e706336627d278c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a0a0d82471cb1119fc1a7b7018e3af394">addListener</a> (<a class="el" href="classValueTree_1_1Listener.html">Listener</a> *listener)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a listener to receive callbacks when this node is changed.  <a href="#a0a0d82471cb1119fc1a7b7018e3af394"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#ac8930aa94cb6e3714ef9e7449d08e5f6">removeListener</a> (<a class="el" href="classValueTree_1_1Listener.html">Listener</a> *listener)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a listener that was previously added with <a class="el" href="classValueTree.html#a0a0d82471cb1119fc1a7b7018e3af394" title="Adds a listener to receive callbacks when this node is changed.">addListener()</a>.  <a href="#ac8930aa94cb6e3714ef9e7449d08e5f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a164ff183e358b982b1a1f5dd1176ab88">sendPropertyChangeMessage</a> (const <a class="el" href="classIdentifier.html">Identifier</a> &amp;property)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes a property-change callback to be triggered for the specified property, calling any listeners that are registered.  <a href="#a164ff183e358b982b1a1f5dd1176ab88"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ElementComparator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classValueTree.html#acdace65667e5bb2036310b4a91dd3a87">sort</a> (ElementComparator &amp;comparator, <a class="el" href="classUndoManager.html">UndoManager</a> *undoManager, bool retainOrderOfEquivalentItems)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This method uses a comparator object to sort the tree's children into order.  <a href="#acdace65667e5bb2036310b4a91dd3a87"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classValueTree.html">ValueTree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a0d2f1bdd6313e53f256ed015986f837a">fromXml</a> (const <a class="el" href="classXmlElement.html">XmlElement</a> &amp;xml)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to recreate a node from its XML representation.  <a href="#a0d2f1bdd6313e53f256ed015986f837a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classValueTree.html">ValueTree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#ad41a9e45b2d15699b4e27bed3b31109c">readFromStream</a> (<a class="el" href="classInputStream.html">InputStream</a> &amp;input)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reloads a tree from a stream that was written with <a class="el" href="classValueTree.html#a4030330dde3b8e95e706336627d278c3" title="Stores this tree (and all its children) in a binary format.">writeToStream()</a>.  <a href="#ad41a9e45b2d15699b4e27bed3b31109c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classValueTree.html">ValueTree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#a9481d856db653baecf76032703858ca5">readFromData</a> (const void *data, size_t numBytes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reloads a tree from a data block that was written with <a class="el" href="classValueTree.html#a4030330dde3b8e95e706336627d278c3" title="Stores this tree (and all its children) in a binary format.">writeToStream()</a>.  <a href="#a9481d856db653baecf76032703858ca5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classValueTree.html">ValueTree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#ab5a0858a2f15fef8b61adb6aa2aadc63">readFromGZIPData</a> (const void *data, size_t numBytes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reloads a tree from a data block that was written with <a class="el" href="classValueTree.html#a4030330dde3b8e95e706336627d278c3" title="Stores this tree (and all its children) in a binary format.">writeToStream()</a> and then zipped using <a class="el" href="classGZIPCompressorOutputStream.html" title="A stream which uses zlib to compress the data written into it.">GZIPCompressorOutputStream</a>.  <a href="#ab5a0858a2f15fef8b61adb6aa2aadc63"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classValueTree.html">ValueTree</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueTree.html#af49e8bf1c5072d0722dff9ef81b84f68">invalid</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An invalid <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> that can be used if you need to return one as an error condition, etc.  <a href="#af49e8bf1c5072d0722dff9ef81b84f68"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A powerful tree structure that can be used to hold free-form data, and which can handle its own undo and redo behaviour. </p>
<p>A <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> contains a list of named properties as var objects, and also holds any number of sub-trees.</p>
<p>Create <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> objects on the stack, and don't be afraid to copy them around, as they're simply a lightweight reference to a shared data container. Creating a copy of another <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> simply creates a new reference to the same underlying object - to make a separate, deep copy of a tree you should explicitly call <a class="el" href="classValueTree.html#ad212f52a1dee540a97b256a57c881fed" title="Returns a deep copy of this tree and all its sub-nodes.">createCopy()</a>.</p>
<p>Each <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> has a type name, in much the same way as an <a class="el" href="classXmlElement.html" title="Used to build a tree of elements representing an XML document.">XmlElement</a> has a tag name, and much of the structure of a <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> is similar to an <a class="el" href="classXmlElement.html" title="Used to build a tree of elements representing an XML document.">XmlElement</a> tree. You can convert a <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> to and from an <a class="el" href="classXmlElement.html" title="Used to build a tree of elements representing an XML document.">XmlElement</a>, and as long as the XML doesn't contain text elements, the conversion works well and makes a good serialisation format. They can also be serialised to a binary format, which is very fast and compact.</p>
<p>All the methods that change data take an optional <a class="el" href="classUndoManager.html" title="Manages a list of undo/redo commands.">UndoManager</a>, which will be used to track any changes to the object. For this to work, you have to be careful to consistently always use the same <a class="el" href="classUndoManager.html" title="Manages a list of undo/redo commands.">UndoManager</a> for all operations to any node inside the tree.</p>
<p>A <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> can only be a child of one parent at a time, so if you're moving one from one tree to another, be careful to always remove it first, before adding it. This could also mess up your undo/redo chain, so be wary! In a debug build you should hit assertions if you try to do anything dangerous, but there are still plenty of ways it could go wrong.</p>
<p>Listeners can be added to a <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> to be told when properies change and when nodes are added or removed.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classvar.html" title="A variant class, that can be used to hold a range of primitive values.">var</a>, <a class="el" href="classXmlElement.html" title="Used to build a tree of elements representing an XML document.">XmlElement</a> </dd></dl>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad5671081941b3db9db42bf7fcbd2629c"></a><!-- doxytag: member="ValueTree::ValueTree" ref="ad5671081941b3db9db42bf7fcbd2629c" args="() noexcept" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classValueTree.html#ad5671081941b3db9db42bf7fcbd2629c">ValueTree::ValueTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an empty, invalid <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a>. </p>
<p>A <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> that is created with this constructor can't actually be used for anything, it's just a default 'null' <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> that can be returned to indicate some sort of failure. To create a real one, use the constructor that takes a string.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classValueTree.html#af49e8bf1c5072d0722dff9ef81b84f68" title="An invalid ValueTree that can be used if you need to return one as an error condition, etc.">ValueTree::invalid</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af2f66bc6973b9a7561af455bd6fb331c"></a><!-- doxytag: member="ValueTree::ValueTree" ref="af2f66bc6973b9a7561af455bd6fb331c" args="(const Identifier &amp;type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classValueTree.html#ad5671081941b3db9db42bf7fcbd2629c">ValueTree::ValueTree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentifier.html">Identifier</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an empty <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> with the given type name. </p>
<p>Like an <a class="el" href="classXmlElement.html" title="Used to build a tree of elements representing an XML document.">XmlElement</a>, each <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> node has a type, which you can access with <a class="el" href="classValueTree.html#a877bc705ae6b3973d4af1b97f5e4c557" title="Returns the type of this node.">getType()</a> and <a class="el" href="classValueTree.html#aa28f5bc26e2704dc725168e54789cff2" title="Returns true if the node has this type.">hasType()</a>. </p>

</div>
</div>
<a class="anchor" id="a685fac19f67d8138645b6ccdb37f6809"></a><!-- doxytag: member="ValueTree::ValueTree" ref="a685fac19f67d8138645b6ccdb37f6809" args="(const ValueTree &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classValueTree.html#ad5671081941b3db9db42bf7fcbd2629c">ValueTree::ValueTree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classValueTree.html">ValueTree</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a reference to another <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a>. </p>

</div>
</div>
<a class="anchor" id="a4e0b4721cb1ec7f79c59192df3b97bcc"></a><!-- doxytag: member="ValueTree::~ValueTree" ref="a4e0b4721cb1ec7f79c59192df3b97bcc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classValueTree.html#a4e0b4721cb1ec7f79c59192df3b97bcc">ValueTree::~ValueTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="abb0ec8b6af470fb80f5fb84d080cd26c"></a><!-- doxytag: member="ValueTree::operator=" ref="abb0ec8b6af470fb80f5fb84d080cd26c" args="(const ValueTree &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classValueTree.html">ValueTree</a>&amp; ValueTree::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classValueTree.html">ValueTree</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Makes this object reference another node. </p>

</div>
</div>
<a class="anchor" id="a078b2ccd7ffad9a0afd3c9d87c976aef"></a><!-- doxytag: member="ValueTree::operator==" ref="a078b2ccd7ffad9a0afd3c9d87c976aef" args="(const ValueTree &amp;other) const noexcept" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ValueTree::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classValueTree.html">ValueTree</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if both this and the other tree node refer to the same underlying structure. </p>
<p>Note that this isn't a value comparison - two independently-created trees which contain identical data are not considered equal. </p>

</div>
</div>
<a class="anchor" id="a855f4a7a94f247b700e15d2ff7fd6436"></a><!-- doxytag: member="ValueTree::operator!=" ref="a855f4a7a94f247b700e15d2ff7fd6436" args="(const ValueTree &amp;other) const noexcept" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ValueTree::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classValueTree.html">ValueTree</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if this and the other node refer to different underlying structures. </p>
<p>Note that this isn't a value comparison - two independently-created trees which contain identical data are not considered equal. </p>

</div>
</div>
<a class="anchor" id="ac6f5b2c18a305fcc6a89e24e5834e298"></a><!-- doxytag: member="ValueTree::isEquivalentTo" ref="ac6f5b2c18a305fcc6a89e24e5834e298" args="(const ValueTree &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classValueTree.html#ac6f5b2c18a305fcc6a89e24e5834e298">ValueTree::isEquivalentTo</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classValueTree.html">ValueTree</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a deep comparison between the properties and children of two trees. </p>
<p>If all the properties and children of the two trees are the same (recursively), this returns true. The normal <a class="el" href="classValueTree.html#a078b2ccd7ffad9a0afd3c9d87c976aef" title="Returns true if both this and the other tree node refer to the same underlying structure.">operator==()</a> only checks whether two trees refer to the same shared data structure, so use this method if you need to do a proper value comparison. </p>

</div>
</div>
<a class="anchor" id="afc7d5ea43143bafac840a8336c5301a5"></a><!-- doxytag: member="ValueTree::isValid" ref="afc7d5ea43143bafac840a8336c5301a5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classValueTree.html#afc7d5ea43143bafac840a8336c5301a5">ValueTree::isValid</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if this node refers to some valid data. </p>
<p>It's hard to create an invalid node, but you might get one returned, e.g. by an out-of-range call to <a class="el" href="classValueTree.html#ae3c7ef24e903b145e7885820898240cb" title="Returns one of this node&#39;s child nodes.">getChild()</a>. </p>

</div>
</div>
<a class="anchor" id="ad212f52a1dee540a97b256a57c881fed"></a><!-- doxytag: member="ValueTree::createCopy" ref="ad212f52a1dee540a97b256a57c881fed" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classValueTree.html">ValueTree</a> <a class="el" href="classValueTree.html#ad212f52a1dee540a97b256a57c881fed">ValueTree::createCopy</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a deep copy of this tree and all its sub-nodes. </p>

</div>
</div>
<a class="anchor" id="a877bc705ae6b3973d4af1b97f5e4c557"></a><!-- doxytag: member="ValueTree::getType" ref="a877bc705ae6b3973d4af1b97f5e4c557" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIdentifier.html">Identifier</a> <a class="el" href="classValueTree.html#a877bc705ae6b3973d4af1b97f5e4c557">ValueTree::getType</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the type of this node. </p>
<p>The type is specified when the <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> is created. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classValueTree.html#aa28f5bc26e2704dc725168e54789cff2" title="Returns true if the node has this type.">hasType</a> </dd></dl>

<p>Referenced by <a class="el" href="classDrawablePath_1_1ValueTreeWrapper_1_1Element.html#ac8097562285b0095974394de4bc59551">DrawablePath::ValueTreeWrapper::Element::getType()</a>.</p>

</div>
</div>
<a class="anchor" id="aa28f5bc26e2704dc725168e54789cff2"></a><!-- doxytag: member="ValueTree::hasType" ref="aa28f5bc26e2704dc725168e54789cff2" args="(const Identifier &amp;typeName) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classValueTree.html#aa28f5bc26e2704dc725168e54789cff2">ValueTree::hasType</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentifier.html">Identifier</a> &amp;&#160;</td>
          <td class="paramname"><em>typeName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the node has this type. </p>
<p>The comparison is case-sensitive. </p>

</div>
</div>
<a class="anchor" id="ac7095a89f79cd50625e92fde56984268"></a><!-- doxytag: member="ValueTree::getProperty" ref="ac7095a89f79cd50625e92fde56984268" args="(const Identifier &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvar.html">var</a>&amp; <a class="el" href="classValueTree.html#ac7095a89f79cd50625e92fde56984268">ValueTree::getProperty</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentifier.html">Identifier</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the value of a named property. </p>
<p>If no such property has been set, this will return a void variant. You can also use operator[] to get a property. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classvar.html" title="A variant class, that can be used to hold a range of primitive values.">var</a>, <a class="el" href="classValueTree.html#ad236114dc2a8c41c799f1fc51d1614bd" title="Changes a named property of the node.">setProperty</a>, <a class="el" href="classValueTree.html#a9dcb765aacb4f0f153fea6c311952d9b" title="Returns true if the node contains a named property.">hasProperty</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a37c064d4411df78b7d1d8ded5cac3ce3"></a><!-- doxytag: member="ValueTree::getProperty" ref="a37c064d4411df78b7d1d8ded5cac3ce3" args="(const Identifier &amp;name, const var &amp;defaultReturnValue) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvar.html">var</a> <a class="el" href="classValueTree.html#ac7095a89f79cd50625e92fde56984268">ValueTree::getProperty</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentifier.html">Identifier</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvar.html">var</a> &amp;&#160;</td>
          <td class="paramname"><em>defaultReturnValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the value of a named property, or a user-specified default if the property doesn't exist. </p>
<p>If no such property has been set, this will return the value of defaultReturnValue. You can also use operator[] and getProperty to get a property. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classvar.html" title="A variant class, that can be used to hold a range of primitive values.">var</a>, <a class="el" href="classValueTree.html#ac7095a89f79cd50625e92fde56984268" title="Returns the value of a named property.">getProperty</a>, <a class="el" href="classValueTree.html#ad236114dc2a8c41c799f1fc51d1614bd" title="Changes a named property of the node.">setProperty</a>, <a class="el" href="classValueTree.html#a9dcb765aacb4f0f153fea6c311952d9b" title="Returns true if the node contains a named property.">hasProperty</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1f5c73dc935caa6577e8e2c9a51b4c86"></a><!-- doxytag: member="ValueTree::operator[]" ref="a1f5c73dc935caa6577e8e2c9a51b4c86" args="(const Identifier &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvar.html">var</a>&amp; ValueTree::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentifier.html">Identifier</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the value of a named property. </p>
<p>If no such property has been set, this will return a void variant. This is the same as calling <a class="el" href="classValueTree.html#ac7095a89f79cd50625e92fde56984268" title="Returns the value of a named property.">getProperty()</a>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classValueTree.html#ac7095a89f79cd50625e92fde56984268" title="Returns the value of a named property.">getProperty</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad236114dc2a8c41c799f1fc51d1614bd"></a><!-- doxytag: member="ValueTree::setProperty" ref="ad236114dc2a8c41c799f1fc51d1614bd" args="(const Identifier &amp;name, const var &amp;newValue, UndoManager *undoManager)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classValueTree.html">ValueTree</a>&amp; <a class="el" href="classValueTree.html#ad236114dc2a8c41c799f1fc51d1614bd">ValueTree::setProperty</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentifier.html">Identifier</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvar.html">var</a> &amp;&#160;</td>
          <td class="paramname"><em>newValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUndoManager.html">UndoManager</a> *&#160;</td>
          <td class="paramname"><em>undoManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes a named property of the node. </p>
<p>The name identifier must not be an empty string. If the undoManager parameter is non-null, its <a class="el" href="classUndoManager.html#ad16c1fef7afaa7187e3b473eff03b214" title="Performs an action and adds it to the undo history list.">UndoManager::perform()</a> method will be used, so that this change can be undone. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classvar.html" title="A variant class, that can be used to hold a range of primitive values.">var</a>, <a class="el" href="classValueTree.html#ac7095a89f79cd50625e92fde56984268" title="Returns the value of a named property.">getProperty</a>, <a class="el" href="classValueTree.html#a2a07b801bd317aa8bf1ee9da5644fc35" title="Removes a property from the node.">removeProperty</a> </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a reference to the value tree, so that you can daisy-chain calls to this method. </dd></dl>

</div>
</div>
<a class="anchor" id="a9dcb765aacb4f0f153fea6c311952d9b"></a><!-- doxytag: member="ValueTree::hasProperty" ref="a9dcb765aacb4f0f153fea6c311952d9b" args="(const Identifier &amp;name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classValueTree.html#a9dcb765aacb4f0f153fea6c311952d9b">ValueTree::hasProperty</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentifier.html">Identifier</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the node contains a named property. </p>

</div>
</div>
<a class="anchor" id="a2a07b801bd317aa8bf1ee9da5644fc35"></a><!-- doxytag: member="ValueTree::removeProperty" ref="a2a07b801bd317aa8bf1ee9da5644fc35" args="(const Identifier &amp;name, UndoManager *undoManager)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classValueTree.html#a2a07b801bd317aa8bf1ee9da5644fc35">ValueTree::removeProperty</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentifier.html">Identifier</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUndoManager.html">UndoManager</a> *&#160;</td>
          <td class="paramname"><em>undoManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes a property from the node. </p>
<p>If the undoManager parameter is non-null, its <a class="el" href="classUndoManager.html#ad16c1fef7afaa7187e3b473eff03b214" title="Performs an action and adds it to the undo history list.">UndoManager::perform()</a> method will be used, so that this change can be undone. </p>

</div>
</div>
<a class="anchor" id="a2f750331b6a680f48751302be9313467"></a><!-- doxytag: member="ValueTree::removeAllProperties" ref="a2f750331b6a680f48751302be9313467" args="(UndoManager *undoManager)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classValueTree.html#a2f750331b6a680f48751302be9313467">ValueTree::removeAllProperties</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classUndoManager.html">UndoManager</a> *&#160;</td>
          <td class="paramname"><em>undoManager</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all properties from the node. </p>
<p>If the undoManager parameter is non-null, its <a class="el" href="classUndoManager.html#ad16c1fef7afaa7187e3b473eff03b214" title="Performs an action and adds it to the undo history list.">UndoManager::perform()</a> method will be used, so that this change can be undone. </p>

</div>
</div>
<a class="anchor" id="ac83190970c072ff95edaebd1ade65c93"></a><!-- doxytag: member="ValueTree::getNumProperties" ref="ac83190970c072ff95edaebd1ade65c93" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classValueTree.html#ac83190970c072ff95edaebd1ade65c93">ValueTree::getNumProperties</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the total number of properties that the node contains. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classValueTree.html#ac7095a89f79cd50625e92fde56984268" title="Returns the value of a named property.">getProperty</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a14517f03840bf3fe5e2cdfc5c2f07588"></a><!-- doxytag: member="ValueTree::getPropertyName" ref="a14517f03840bf3fe5e2cdfc5c2f07588" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIdentifier.html">Identifier</a> <a class="el" href="classValueTree.html#a14517f03840bf3fe5e2cdfc5c2f07588">ValueTree::getPropertyName</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the identifier of the property with a given index. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classValueTree.html#ac83190970c072ff95edaebd1ade65c93" title="Returns the total number of properties that the node contains.">getNumProperties</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa36d40c533583c723be757c77ade1a5c"></a><!-- doxytag: member="ValueTree::getPropertyAsValue" ref="aa36d40c533583c723be757c77ade1a5c" args="(const Identifier &amp;name, UndoManager *undoManager)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classValue.html">Value</a> <a class="el" href="classValueTree.html#aa36d40c533583c723be757c77ade1a5c">ValueTree::getPropertyAsValue</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentifier.html">Identifier</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUndoManager.html">UndoManager</a> *&#160;</td>
          <td class="paramname"><em>undoManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a <a class="el" href="classValue.html" title="Represents a shared variant value.">Value</a> object that can be used to control and respond to one of the tree's properties. </p>
<p>The <a class="el" href="classValue.html" title="Represents a shared variant value.">Value</a> object will maintain a reference to this tree, and will use the undo manager when it needs to change the value. Attaching a <a class="el" href="classValue_1_1Listener.html" title="Receives callbacks when a Value object changes.">Value::Listener</a> to the value object will provide callbacks whenever the property changes. </p>

</div>
</div>
<a class="anchor" id="ab4e869902306be8d60d056a4192383c2"></a><!-- doxytag: member="ValueTree::getNumChildren" ref="ab4e869902306be8d60d056a4192383c2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classValueTree.html#ab4e869902306be8d60d056a4192383c2">ValueTree::getNumChildren</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of child nodes belonging to this one. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classValueTree.html#ae3c7ef24e903b145e7885820898240cb" title="Returns one of this node&#39;s child nodes.">getChild</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae3c7ef24e903b145e7885820898240cb"></a><!-- doxytag: member="ValueTree::getChild" ref="ae3c7ef24e903b145e7885820898240cb" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classValueTree.html">ValueTree</a> <a class="el" href="classValueTree.html#ae3c7ef24e903b145e7885820898240cb">ValueTree::getChild</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns one of this node's child nodes. </p>
<p>If the index is out of range, it'll return an invalid node. (See <a class="el" href="classValueTree.html#afc7d5ea43143bafac840a8336c5301a5" title="Returns true if this node refers to some valid data.">isValid()</a> to find out whether a node is valid). </p>

</div>
</div>
<a class="anchor" id="a00e9d09ad2439b9eb5cb79cb146c5a73"></a><!-- doxytag: member="ValueTree::getChildWithName" ref="a00e9d09ad2439b9eb5cb79cb146c5a73" args="(const Identifier &amp;type) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classValueTree.html">ValueTree</a> <a class="el" href="classValueTree.html#a00e9d09ad2439b9eb5cb79cb146c5a73">ValueTree::getChildWithName</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentifier.html">Identifier</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the first child node with the speficied type name. </p>
<p>If no such node is found, it'll return an invalid node. (See <a class="el" href="classValueTree.html#afc7d5ea43143bafac840a8336c5301a5" title="Returns true if this node refers to some valid data.">isValid()</a> to find out whether a node is valid). </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classValueTree.html#aafb29876616f005939915de3e6968818" title="Returns the first child node with the speficied type name, creating and adding a child with this name...">getOrCreateChildWithName</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aafb29876616f005939915de3e6968818"></a><!-- doxytag: member="ValueTree::getOrCreateChildWithName" ref="aafb29876616f005939915de3e6968818" args="(const Identifier &amp;type, UndoManager *undoManager)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classValueTree.html">ValueTree</a> <a class="el" href="classValueTree.html#aafb29876616f005939915de3e6968818">ValueTree::getOrCreateChildWithName</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentifier.html">Identifier</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUndoManager.html">UndoManager</a> *&#160;</td>
          <td class="paramname"><em>undoManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the first child node with the speficied type name, creating and adding a child with this name if there wasn't already one there. </p>
<p>The only time this will return an invalid object is when the object that you're calling the method on is itself invalid. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classValueTree.html#a00e9d09ad2439b9eb5cb79cb146c5a73" title="Returns the first child node with the speficied type name.">getChildWithName</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a99c2e890ecbed6c7fab83c1a95d824a6"></a><!-- doxytag: member="ValueTree::getChildWithProperty" ref="a99c2e890ecbed6c7fab83c1a95d824a6" args="(const Identifier &amp;propertyName, const var &amp;propertyValue) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classValueTree.html">ValueTree</a> <a class="el" href="classValueTree.html#a99c2e890ecbed6c7fab83c1a95d824a6">ValueTree::getChildWithProperty</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentifier.html">Identifier</a> &amp;&#160;</td>
          <td class="paramname"><em>propertyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvar.html">var</a> &amp;&#160;</td>
          <td class="paramname"><em>propertyValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Looks for the first child node that has the speficied property value. </p>
<p>This will scan the child nodes in order, until it finds one that has property that matches the specified value.</p>
<p>If no such node is found, it'll return an invalid node. (See <a class="el" href="classValueTree.html#afc7d5ea43143bafac840a8336c5301a5" title="Returns true if this node refers to some valid data.">isValid()</a> to find out whether a node is valid). </p>

</div>
</div>
<a class="anchor" id="a93d639299ef9dfedc651544e05f06693"></a><!-- doxytag: member="ValueTree::addChild" ref="a93d639299ef9dfedc651544e05f06693" args="(const ValueTree &amp;child, int index, UndoManager *undoManager)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classValueTree.html#a93d639299ef9dfedc651544e05f06693">ValueTree::addChild</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classValueTree.html">ValueTree</a> &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUndoManager.html">UndoManager</a> *&#160;</td>
          <td class="paramname"><em>undoManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a child to this node. </p>
<p>Make sure that the child is removed from any former parent node before calling this, or you'll hit an assertion.</p>
<p>If the index is &lt; 0 or greater than the current number of child nodes, the new node will be added at the end of the list.</p>
<p>If the undoManager parameter is non-null, its <a class="el" href="classUndoManager.html#ad16c1fef7afaa7187e3b473eff03b214" title="Performs an action and adds it to the undo history list.">UndoManager::perform()</a> method will be used, so that this change can be undone. </p>

</div>
</div>
<a class="anchor" id="a52b15bdb0b4a04b81c04e7059bb926c4"></a><!-- doxytag: member="ValueTree::removeChild" ref="a52b15bdb0b4a04b81c04e7059bb926c4" args="(const ValueTree &amp;child, UndoManager *undoManager)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classValueTree.html#a52b15bdb0b4a04b81c04e7059bb926c4">ValueTree::removeChild</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classValueTree.html">ValueTree</a> &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUndoManager.html">UndoManager</a> *&#160;</td>
          <td class="paramname"><em>undoManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the specified child from this node's child-list. </p>
<p>If the undoManager parameter is non-null, its <a class="el" href="classUndoManager.html#ad16c1fef7afaa7187e3b473eff03b214" title="Performs an action and adds it to the undo history list.">UndoManager::perform()</a> method will be used, so that this change can be undone. </p>

</div>
</div>
<a class="anchor" id="a3bee3734652dec6bb1d5c351a1268fc0"></a><!-- doxytag: member="ValueTree::removeChild" ref="a3bee3734652dec6bb1d5c351a1268fc0" args="(int childIndex, UndoManager *undoManager)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classValueTree.html#a52b15bdb0b4a04b81c04e7059bb926c4">ValueTree::removeChild</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>childIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUndoManager.html">UndoManager</a> *&#160;</td>
          <td class="paramname"><em>undoManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes a child from this node's child-list. </p>
<p>If the undoManager parameter is non-null, its <a class="el" href="classUndoManager.html#ad16c1fef7afaa7187e3b473eff03b214" title="Performs an action and adds it to the undo history list.">UndoManager::perform()</a> method will be used, so that this change can be undone. </p>

</div>
</div>
<a class="anchor" id="a91f8a28e02a782b0c95f855d0c29f0d9"></a><!-- doxytag: member="ValueTree::removeAllChildren" ref="a91f8a28e02a782b0c95f855d0c29f0d9" args="(UndoManager *undoManager)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classValueTree.html#a91f8a28e02a782b0c95f855d0c29f0d9">ValueTree::removeAllChildren</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classUndoManager.html">UndoManager</a> *&#160;</td>
          <td class="paramname"><em>undoManager</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all child-nodes from this node. </p>
<p>If the undoManager parameter is non-null, its <a class="el" href="classUndoManager.html#ad16c1fef7afaa7187e3b473eff03b214" title="Performs an action and adds it to the undo history list.">UndoManager::perform()</a> method will be used, so that this change can be undone. </p>

</div>
</div>
<a class="anchor" id="ab7d20bf6964bfc8c4a975543bca8ce53"></a><!-- doxytag: member="ValueTree::moveChild" ref="ab7d20bf6964bfc8c4a975543bca8ce53" args="(int currentIndex, int newIndex, UndoManager *undoManager)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classValueTree.html#ab7d20bf6964bfc8c4a975543bca8ce53">ValueTree::moveChild</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>currentIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUndoManager.html">UndoManager</a> *&#160;</td>
          <td class="paramname"><em>undoManager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves one of the children to a different index. </p>
<p>This will move the child to a specified index, shuffling along any intervening items as required. So for example, if you have a list of { 0, 1, 2, 3, 4, 5 }, then calling move (2, 4) would result in { 0, 1, 3, 4, 2, 5 }.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">currentIndex</td><td>the index of the item to be moved. If this isn't a valid index, then nothing will be done </td></tr>
    <tr><td class="paramname">newIndex</td><td>the index at which you'd like this item to end up. If this is less than zero, the value will be moved to the end of the list </td></tr>
    <tr><td class="paramname">undoManager</td><td>the optional <a class="el" href="classUndoManager.html" title="Manages a list of undo/redo commands.">UndoManager</a> to use to store this transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af55de3861c98a6441e04891690784eff"></a><!-- doxytag: member="ValueTree::isAChildOf" ref="af55de3861c98a6441e04891690784eff" args="(const ValueTree &amp;possibleParent) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classValueTree.html#af55de3861c98a6441e04891690784eff">ValueTree::isAChildOf</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classValueTree.html">ValueTree</a> &amp;&#160;</td>
          <td class="paramname"><em>possibleParent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if this node is anywhere below the specified parent node. </p>
<p>This returns true if the node is a child-of-a-child, as well as a direct child. </p>

</div>
</div>
<a class="anchor" id="aed934c5a006a21f8edf4c1b7fe39bc48"></a><!-- doxytag: member="ValueTree::indexOf" ref="aed934c5a006a21f8edf4c1b7fe39bc48" args="(const ValueTree &amp;child) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classValueTree.html#aed934c5a006a21f8edf4c1b7fe39bc48">ValueTree::indexOf</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classValueTree.html">ValueTree</a> &amp;&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the index of a child item in this parent. </p>
<p>If the child isn't found, this returns -1. </p>

</div>
</div>
<a class="anchor" id="a238a440b17653c87e1b0981515bc2bfa"></a><!-- doxytag: member="ValueTree::getParent" ref="a238a440b17653c87e1b0981515bc2bfa" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classValueTree.html">ValueTree</a> <a class="el" href="classValueTree.html#a238a440b17653c87e1b0981515bc2bfa">ValueTree::getParent</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the parent node that contains this one. </p>
<p>If the node has no parent, this will return an invalid node. (See <a class="el" href="classValueTree.html#afc7d5ea43143bafac840a8336c5301a5" title="Returns true if this node refers to some valid data.">isValid()</a> to find out whether a node is valid). </p>

</div>
</div>
<a class="anchor" id="aeaad7cad64013775bdf12b871c07abb7"></a><!-- doxytag: member="ValueTree::getSibling" ref="aeaad7cad64013775bdf12b871c07abb7" args="(int delta) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classValueTree.html">ValueTree</a> <a class="el" href="classValueTree.html#aeaad7cad64013775bdf12b871c07abb7">ValueTree::getSibling</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>delta</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns one of this node's siblings in its parent's child list. </p>
<p>The delta specifies how far to move through the list, so a value of 1 would return the node that follows this one, -1 would return the node before it, 0 will return this node itself, etc. If the requested position is beyond the range of available nodes, this will return <a class="el" href="classValueTree.html#af49e8bf1c5072d0722dff9ef81b84f68" title="An invalid ValueTree that can be used if you need to return one as an error condition, etc.">ValueTree::invalid</a>. </p>

</div>
</div>
<a class="anchor" id="ad4b6941292f6ba19b1f4c7a91b82f957"></a><!-- doxytag: member="ValueTree::createXml" ref="ad4b6941292f6ba19b1f4c7a91b82f957" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXmlElement.html">XmlElement</a>* <a class="el" href="classValueTree.html#ad4b6941292f6ba19b1f4c7a91b82f957">ValueTree::createXml</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an <a class="el" href="classXmlElement.html" title="Used to build a tree of elements representing an XML document.">XmlElement</a> that holds a complete image of this node and all its children. </p>
<p>If this node is invalid, this may return 0. Otherwise, the XML that is produced can be used to recreate a similar node by calling <a class="el" href="classValueTree.html#a0d2f1bdd6313e53f256ed015986f837a" title="Tries to recreate a node from its XML representation.">fromXml()</a> </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classValueTree.html#a0d2f1bdd6313e53f256ed015986f837a" title="Tries to recreate a node from its XML representation.">fromXml</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0d2f1bdd6313e53f256ed015986f837a"></a><!-- doxytag: member="ValueTree::fromXml" ref="a0d2f1bdd6313e53f256ed015986f837a" args="(const XmlElement &amp;xml)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classValueTree.html">ValueTree</a> <a class="el" href="classValueTree.html#a0d2f1bdd6313e53f256ed015986f837a">ValueTree::fromXml</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXmlElement.html">XmlElement</a> &amp;&#160;</td>
          <td class="paramname"><em>xml</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to recreate a node from its XML representation. </p>
<p>This isn't designed to cope with random XML data - for a sensible result, it should only be fed XML that was created by the <a class="el" href="classValueTree.html#ad4b6941292f6ba19b1f4c7a91b82f957" title="Creates an XmlElement that holds a complete image of this node and all its children.">createXml()</a> method. </p>

</div>
</div>
<a class="anchor" id="a4030330dde3b8e95e706336627d278c3"></a><!-- doxytag: member="ValueTree::writeToStream" ref="a4030330dde3b8e95e706336627d278c3" args="(OutputStream &amp;output)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classValueTree.html#a4030330dde3b8e95e706336627d278c3">ValueTree::writeToStream</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOutputStream.html">OutputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stores this tree (and all its children) in a binary format. </p>
<p>Once written, the data can be read back with <a class="el" href="classValueTree.html#ad41a9e45b2d15699b4e27bed3b31109c" title="Reloads a tree from a stream that was written with writeToStream().">readFromStream()</a>.</p>
<p>It's much faster to load/save your tree in binary form than as XML, but obviously isn't human-readable. </p>

</div>
</div>
<a class="anchor" id="ad41a9e45b2d15699b4e27bed3b31109c"></a><!-- doxytag: member="ValueTree::readFromStream" ref="ad41a9e45b2d15699b4e27bed3b31109c" args="(InputStream &amp;input)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classValueTree.html">ValueTree</a> <a class="el" href="classValueTree.html#ad41a9e45b2d15699b4e27bed3b31109c">ValueTree::readFromStream</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classInputStream.html">InputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reloads a tree from a stream that was written with <a class="el" href="classValueTree.html#a4030330dde3b8e95e706336627d278c3" title="Stores this tree (and all its children) in a binary format.">writeToStream()</a>. </p>

</div>
</div>
<a class="anchor" id="a9481d856db653baecf76032703858ca5"></a><!-- doxytag: member="ValueTree::readFromData" ref="a9481d856db653baecf76032703858ca5" args="(const void *data, size_t numBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classValueTree.html">ValueTree</a> <a class="el" href="classValueTree.html#a9481d856db653baecf76032703858ca5">ValueTree::readFromData</a> </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reloads a tree from a data block that was written with <a class="el" href="classValueTree.html#a4030330dde3b8e95e706336627d278c3" title="Stores this tree (and all its children) in a binary format.">writeToStream()</a>. </p>

</div>
</div>
<a class="anchor" id="ab5a0858a2f15fef8b61adb6aa2aadc63"></a><!-- doxytag: member="ValueTree::readFromGZIPData" ref="ab5a0858a2f15fef8b61adb6aa2aadc63" args="(const void *data, size_t numBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classValueTree.html">ValueTree</a> <a class="el" href="classValueTree.html#ab5a0858a2f15fef8b61adb6aa2aadc63">ValueTree::readFromGZIPData</a> </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reloads a tree from a data block that was written with <a class="el" href="classValueTree.html#a4030330dde3b8e95e706336627d278c3" title="Stores this tree (and all its children) in a binary format.">writeToStream()</a> and then zipped using <a class="el" href="classGZIPCompressorOutputStream.html" title="A stream which uses zlib to compress the data written into it.">GZIPCompressorOutputStream</a>. </p>

</div>
</div>
<a class="anchor" id="a0a0d82471cb1119fc1a7b7018e3af394"></a><!-- doxytag: member="ValueTree::addListener" ref="a0a0d82471cb1119fc1a7b7018e3af394" args="(Listener *listener)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classValueTree.html#a0a0d82471cb1119fc1a7b7018e3af394">ValueTree::addListener</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classValueTree_1_1Listener.html">Listener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a listener to receive callbacks when this node is changed. </p>
<p>The listener is added to this specific <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> object, and not to the shared object that it refers to. When this object is deleted, all the listeners will be lost, even if other references to the same <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> still exist. And if you use the operator= to make this refer to a different <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a>, any listeners will begin listening to changes to the new tree instead of the old one.</p>
<p>When you're adding a listener, make sure that you add it to a <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> instance that will last for as long as you need the listener. In general, you'd never want to add a listener to a local stack-based <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a>, and would usually add one to a member variable.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classValueTree.html#ac8930aa94cb6e3714ef9e7449d08e5f6" title="Removes a listener that was previously added with addListener().">removeListener</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac8930aa94cb6e3714ef9e7449d08e5f6"></a><!-- doxytag: member="ValueTree::removeListener" ref="ac8930aa94cb6e3714ef9e7449d08e5f6" args="(Listener *listener)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classValueTree.html#ac8930aa94cb6e3714ef9e7449d08e5f6">ValueTree::removeListener</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classValueTree_1_1Listener.html">Listener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes a listener that was previously added with <a class="el" href="classValueTree.html#a0a0d82471cb1119fc1a7b7018e3af394" title="Adds a listener to receive callbacks when this node is changed.">addListener()</a>. </p>

</div>
</div>
<a class="anchor" id="a164ff183e358b982b1a1f5dd1176ab88"></a><!-- doxytag: member="ValueTree::sendPropertyChangeMessage" ref="a164ff183e358b982b1a1f5dd1176ab88" args="(const Identifier &amp;property)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classValueTree.html#a164ff183e358b982b1a1f5dd1176ab88">ValueTree::sendPropertyChangeMessage</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentifier.html">Identifier</a> &amp;&#160;</td>
          <td class="paramname"><em>property</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Causes a property-change callback to be triggered for the specified property, calling any listeners that are registered. </p>

</div>
</div>
<a class="anchor" id="acdace65667e5bb2036310b4a91dd3a87"></a><!-- doxytag: member="ValueTree::sort" ref="acdace65667e5bb2036310b4a91dd3a87" args="(ElementComparator &amp;comparator, UndoManager *undoManager, bool retainOrderOfEquivalentItems)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementComparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classValueTree.html#acdace65667e5bb2036310b4a91dd3a87">ValueTree::sort</a> </td>
          <td>(</td>
          <td class="paramtype">ElementComparator &amp;&#160;</td>
          <td class="paramname"><em>comparator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUndoManager.html">UndoManager</a> *&#160;</td>
          <td class="paramname"><em>undoManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retainOrderOfEquivalentItems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This method uses a comparator object to sort the tree's children into order. </p>
<p>The object provided must have a method of the form: </p>
<div class="fragment"><pre class="fragment">        <span class="keywordtype">int</span> compareElements (<span class="keyword">const</span> <a class="code" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a>&amp; first, <span class="keyword">const</span> <a class="code" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a>&amp; second);
</pre></div><p>..and this method must return:</p>
<ul>
<li>a value of &lt; 0 if the first comes before the second</li>
<li>a value of 0 if the two objects are equivalent</li>
<li>a value of &gt; 0 if the second comes before the first</li>
</ul>
<p>To improve performance, the compareElements() method can be declared as static or const.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">comparator</td><td>the comparator to use for comparing elements. </td></tr>
    <tr><td class="paramname">undoManager</td><td>optional <a class="el" href="classUndoManager.html" title="Manages a list of undo/redo commands.">UndoManager</a> for storing the changes </td></tr>
    <tr><td class="paramname">retainOrderOfEquivalentItems</td><td>if this is true, then items which the comparator says are equivalent will be kept in the order in which they currently appear in the array. This is slower to perform, but may be important in some cases. If it's false, a faster algorithm is used, but equivalent elements may be rearranged. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classOwnedArray.html#af0cdef04b3c45c6e6f684ca56c1349dc">OwnedArray&lt; ObjectClass, TypeOfCriticalSectionToUse &gt;::sort()</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="af49e8bf1c5072d0722dff9ef81b84f68"></a><!-- doxytag: member="ValueTree::invalid" ref="af49e8bf1c5072d0722dff9ef81b84f68" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classValueTree.html">ValueTree</a> <a class="el" href="classValueTree.html#af49e8bf1c5072d0722dff9ef81b84f68">ValueTree::invalid</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An invalid <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> that can be used if you need to return one as an error condition, etc. </p>
<p>This invalid object is equivalent to <a class="el" href="classValueTree.html" title="A powerful tree structure that can be used to hold free-form data, and which can handle its own undo ...">ValueTree</a> created with its default constructor. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="juce__ValueTree_8h.html">juce_ValueTree.h</a></li>
</ul>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/>
<address class="footer"><small>All content &copy Raw Material Software Ltd. -- Generated on Tue Apr 10 2012 12:41:48 by&#160;<a href="http://www.doxygen.org/index.html">doxygen</a> 1.7.6.1</small></address><br/>
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-19759318-1']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
</html>
